<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>objz@portfolio:~$ _</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../style/styles.css" />
    <style>
      /* 3D Scene Styles */
      #scene-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
        background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      }

      /* Hidden terminal element, used as canvas texture */
      #terminal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        width: 800px;
        height: 600px;
        visibility: hidden;
      }

      /* When rendering as a texture, move it off-screen */
      #terminal.texture-mode {
        visibility: hidden;
        position: absolute;
        top: -10000px;
        left: -10000px;
        transform: none;
        z-index: -1;
      }

      /* Loading screen */
      #loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        color: #8be9fd;
        font-family: "JetBrains Mono", monospace;
        transition: opacity 0.5s ease;
      }
      #loading.hidden {
        opacity: 0;
        pointer-events: none;
      }
      .loading-text {
        font-size: 18px;
        margin-bottom: 20px;
        text-shadow: 0 0 10px rgba(139, 233, 253, 0.5);
      }
      .loading-bar {
        width: 300px;
        height: 4px;
        background: #333;
        border-radius: 2px;
        overflow: hidden;
      }
      .loading-progress {
        height: 100%;
        background: linear-gradient(90deg, #8be9fd, #50fa7b);
        width: 0%;
        transition: width 0.3s ease;
        box-shadow: 0 0 10px rgba(139, 233, 253, 0.3);
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div id="loading">
      <div class="loading-text">Initializing 3D Terminal...</div>
      <div class="loading-bar">
        <div class="loading-progress" id="loading-progress"></div>
      </div>
    </div>

    <!-- 3D Scene Container -->
    <div id="scene-container"></div>

    <!-- Terminal (hidden, used only as three.js texture) -->
    <div id="terminal">
      <div id="terminal-header">
        <div class="window-controls">
          <span class="control close"></span>
          <span class="control minimize"></span>
          <span class="control maximize"></span>
        </div>
        <div class="terminal-title">objz@portfolio:~</div>
      </div>
      <div id="terminal-body">
        <div id="terminal-output"></div>
      </div>
    </div>

    <!-- Import map for Three.js -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <!-- WASM-powered terminal writes into #terminal-output -->
    <script type="module" src="../js/index.js"></script>

    <!-- 3D integration -->
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      class Terminal3D {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.pcModel = null;
          this.screenMesh = null;
          this.terminalTexture = null;
          this.isTerminalFocused = false;
          this.animationId = null;
          this.init();
        }

        async init() {
          try {
            this.updateLoadingProgress(10);
            await this.setupScene();
            this.updateLoadingProgress(30);
            await this.loadPCModel();
            this.updateLoadingProgress(60);
            await this.setupTerminalTexture();
            this.updateLoadingProgress(80);
            this.setupEventListeners();
            this.updateLoadingProgress(100);
            this.hideLoading();
            this.animate();
          } catch (e) {
            console.error("3D init failed:", e);
            this.showError();
          }
        }

        updateLoadingProgress(p) {
          const bar = document.getElementById("loading-progress");
          if (bar) bar.style.width = p + "%";
        }

        hideLoading() {
          setTimeout(() => {
            const L = document.getElementById("loading");
            if (L) L.classList.add("hidden");
          }, 500);
        }

        showError() {
          const txt = document.querySelector(".loading-text");
          if (txt) {
            txt.textContent = "Failed to load 3D. Showing terminal.";
            txt.style.color = "#ff5555";
          }
          setTimeout(() => {
            const L = document.getElementById("loading");
            if (L) L.classList.add("hidden");
            const term = document.getElementById("terminal");
            if (term) term.style.visibility = "visible";
          }, 2000);
        }

        async setupScene() {
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x0a0a0a);
          this.camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            100,
          );
          this.camera.position.set(0, 1.5, 3);
          this.renderer = new THREE.WebGLRenderer({ antialias: true });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          document
            .getElementById("scene-container")
            .appendChild(this.renderer.domElement);
          this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement,
          );
          this.controls.enableDamping = true;
          this.controls.target.set(0, 1, 0);

          // lighting
          this.scene.add(new THREE.HemisphereLight(0x8be9fd, 0x444444, 0.3));
        }

        async loadPCModel() {
          console.log("Loading PC model...");
          return new Promise((resolve) => {
            const loader = new GLTFLoader();
            loader.load(
              "./pc.glb",
              (gltf) => {
                console.log("Model loaded");
                this.pcModel = gltf.scene;
                this.pcModel.scale.setScalar(1);
                this.pcModel.position.set(0, 0, 0);

                // enable shadows & find screen
                this.pcModel.traverse((c) => {
                  if (c.isMesh) {
                    c.castShadow = c.receiveShadow = true;
                    const n = c.name.toLowerCase();
                    const m = c.material?.name?.toLowerCase() || "";
                    if (
                      n.includes("screen") ||
                      n.includes("monitor") ||
                      m.includes("screen") ||
                      m.includes("monitor")
                    ) {
                      this.screenMesh = c;
                      console.log("Found screen:", c.name);
                    }
                  }
                });
                if (!this.screenMesh) {
                  this.findScreenMesh();
                }
                this.scene.add(this.pcModel);
                resolve();
              },
              (prog) => {
                const pct = 30 + (prog.loaded / prog.total) * 30;
                this.updateLoadingProgress(pct);
              },
              (err) => {
                console.warn("Model load failed, using fallback:", err);
                this.createFallbackPC();
                resolve();
              },
            );
          });
        }

        // If no named screen, pick the largest flat surface :contentReference[oaicite:0]{index=0}
        findScreenMesh() {
          const candidates = [];
          this.pcModel.traverse((c) => {
            if (c.isMesh && c.geometry) {
              const box = new THREE.Box3().setFromObject(c);
              const s = box.getSize(new THREE.Vector3());
              const flat =
                Math.min(s.x, s.y, s.z) < Math.max(s.x, s.y, s.z) * 0.1;
              const big = Math.max(s.x, s.y, s.z) > 0.5;
              if (flat && big)
                candidates.push({ mesh: c, area: s.x * s.y * s.z });
            }
          });
          if (candidates.length) {
            candidates.sort((a, b) => b.area - a.area);
            this.screenMesh = candidates[0].mesh;
          } else {
            this.pcModel.traverse((c) => {
              if (!this.screenMesh && c.isMesh) this.screenMesh = c;
            });
          }
        }

        // Apply a canvas texture to the screen mesh :contentReference[oaicite:1]{index=1}
        async setupTerminalTexture() {
          const t = document.getElementById("terminal");
          if (t) t.classList.add("texture-mode");
          await new Promise((r) => requestAnimationFrame(r));

          const canvas = document.createElement("canvas");
          canvas.width = 1024;
          canvas.height = 768;
          const ctx = canvas.getContext("2d");
          this.terminalTexture = new THREE.CanvasTexture(canvas);
          this.terminalTexture.minFilter = THREE.LinearFilter;
          this.terminalTexture.magFilter = THREE.LinearFilter;
          this.terminalTexture.flipY = false;

          if (this.screenMesh) {
            this.screenMesh.material = new THREE.MeshBasicMaterial({
              map: this.terminalTexture,
              emissive: new THREE.Color(0x002200),
              emissiveIntensity: 0.2,
            });
          }

          this.updateTerminalTexture = () => {
            try {
              ctx.fillStyle = "#0a0a0a";
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              // header & controls
              ctx.fillStyle = "#1a1a1a";
              ctx.fillRect(0, 0, canvas.width, 60);
              [
                ["#ff5555", 30],
                ["#ffb86c", 60],
                ["#50fa7b", 90],
              ].forEach(([col, x]) => {
                ctx.fillStyle = col;
                ctx.beginPath();
                ctx.arc(x, 30, 8, 0, Math.PI * 2);
                ctx.fill();
              });

              // content: read DOM lines and draw
              ctx.fillStyle = "#8be9fd";
              ctx.font = "16px 'JetBrains Mono'";
              const lines = Array.from(
                document.querySelectorAll("#terminal-output div"),
              ).map((d) => d.textContent || "");
              lines.forEach((ln, i) => ctx.fillText(ln, 10, 90 + i * 20));

              this.terminalTexture.needsUpdate = true;
            } catch (e) {
              console.warn("Texture update failed:", e);
            }
          };

          this.updateTerminalTexture();
          setInterval(() => {
            if (!this.isTerminalFocused) this.updateTerminalTexture();
          }, 500);
        }

        setupEventListeners() {
          window.addEventListener("resize", () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          });

          const ray = new THREE.Raycaster();
          const mouse = new THREE.Vector2();
          this.renderer.domElement.addEventListener("click", (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            ray.setFromCamera(mouse, this.camera);
            ray.intersectObjects(this.scene.children, true).forEach((inter) => {
              if (inter.object === this.screenMesh) {
                this.updateTerminalTexture();
              }
            });
          });
        }

        animate() {
          this.animationId = requestAnimationFrame(() => this.animate());
          this.controls.update();
          if (this.pcModel && !this.isTerminalFocused) {
            this.pcModel.rotation.y += 0.002;
          }
          this.renderer.render(this.scene, this.camera);
        }

        dispose() {
          if (this.animationId) cancelAnimationFrame(this.animationId);
          this.renderer.dispose();
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        setTimeout(() => {
          window.terminal3d = new Terminal3D();
        }, 1000);
      });
      window.addEventListener("beforeunload", () => {
        if (window.terminal3d) window.terminal3d.dispose();
      });
    </script>
  </body>
</html>
