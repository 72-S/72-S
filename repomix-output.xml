This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
    snake.yml
js/
  index.js
  model.js
src/
  ascii_art/
    mod.rs
    user.rs
  boot/
    boot.rs
    mod.rs
  commands/
    filesystem.rs
    misc.rs
    mod.rs
    processor.rs
    system.rs
  input/
    history.rs
    mod.rs
    setup.rs
  terminal/
    autocomplete.rs
    core.rs
    line_buffer.rs
    mod.rs
    renderer.rs
  utils/
    mod.rs
    panic.rs
  lib.rs
static/
  index.html
style/
  styles.css
.gitignore
build.sh
Cargo.toml
README.md
serve.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/ascii_art/mod.rs">
pub mod user;

use user::user;

#[derive(Clone)]
pub struct AsciiArt;

impl AsciiArt {
    pub fn get_user() -> String {
        user()
    }
}
</file>

<file path="src/ascii_art/user.rs">
pub fn user() -> String {
    r#"
   ___  ___    _ ____
  / _ \| _ )_ | |_  /
 | (_) | _ \ || |/ / 
  \___/|___/\__//___|

  [ me@objz.dev ]

  "Code is poetry in motion"
    "#
    .to_string()
}
</file>

<file path="src/commands/mod.rs">
pub mod filesystem;
pub mod misc;
pub mod processor;
pub mod system;

pub use processor::CommandHandler;
</file>

<file path="src/commands/system.rs">
use crate::ascii_art::AsciiArt;
use std::sync::OnceLock;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = Date)]
    fn now() -> f64;

    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

static START_TIME: OnceLock<f64> = OnceLock::new();
pub fn init() {
    START_TIME.set(now()).ok();
}

pub fn clear(_args: &[&str]) -> String {
    "CLEAR_SCREEN".to_string()
}

pub fn echo(args: &[&str]) -> String {
    if args.is_empty() {
        String::new()
    } else if args[0] == "$USER" {
        AsciiArt::get_user()
    } else {
        args.join(" ")
    }
}

pub fn date(_args: &[&str]) -> String {
    let millis = now();
    let date = js_sys::Date::new(&JsValue::from_f64(millis));
    date.to_iso_string().into()
}

pub fn uptime(_args: &[&str]) -> String {
    let start = *START_TIME.get().unwrap_or(&now());
    let elapsed = now() - start;

    let total_secs = (elapsed / 1000.0) as u64;
    let hours = total_secs / 3600;
    let minutes = (total_secs % 3600) / 60;
    let seconds = total_secs % 60;

    format!("{:02}h {:02}m {:02}s", hours, minutes, seconds)
}

pub fn neofetch(_args: &[&str]) -> String {
    r#"                   -`                    objz@portfolio
                  .o+`                   -----------------
                 `ooo/                   OS: Portfolio Linux x86_64
                `+oooo:                  Host: GitHub Pages
               `+oooooo:                 Kernel: WASM 6.6.6
               -+oooooo+:                Uptime: 17 days, 13 hours, 28 mins
             `/:-:++oooo+:               Packages: 42 (rust), 13 (npm)
            `/++++/+++++++:              Shell: objz-shell 3.0.0
           `/++++++++++++++:             Resolution: 1920x1080
          `/+++ooooooooo++++/            WM: Terminal Emulator
         ./ooosssso++osssssso+`          Theme: Dark
        .oossssso-````/ossssss+`         Icons: ASCII Art Pack
       -osssssso.      :ssssssso.        Terminal: objz-term
      :osssssss/        +sssso+++.
     /ossssssss/        +ssssooo/-       Memory: 521MiB / âˆžGiB
   `/ossssso+/:-        -:/+osssso+-     
  `+sso+:-`                 `.-/+oso:    
 `++:.                           `-/+/   
 .`                                 `/   "#
        .to_string()
}
</file>

<file path="src/input/history.rs">
#[derive(Clone)]
pub struct CommandHistory {
    history: Vec<String>,
    current_index: Option<usize>,
}

impl CommandHistory {
    pub fn new() -> Self {
        Self {
            history: Vec::new(),
            current_index: None,
        }
    }

    pub fn add(&mut self, command: String) {
        if !command.trim().is_empty() && self.history.last() != Some(&command) {
            self.history.push(command);
        }
        self.current_index = None;
    }

    pub fn prev(&mut self) -> Option<&String> {
        if self.history.is_empty() {
            return None;
        }

        let new_index = match self.current_index {
            None => self.history.len() - 1,
            Some(0) => return self.history.get(0),
            Some(i) => i - 1,
        };

        self.current_index = Some(new_index);
        self.history.get(new_index)
    }

    pub fn next(&mut self) -> Option<&String> {
        match self.current_index {
            None => None,
            Some(i) if i >= self.history.len() - 1 => {
                self.current_index = None;
                None
            }
            Some(i) => {
                let new_index = i + 1;
                self.current_index = Some(new_index);
                self.history.get(new_index)
            }
        }
    }
}
</file>

<file path="src/input/mod.rs">
pub mod history;
pub mod setup;
</file>

<file path=".github/workflows/snake.yml">
name: Generate snake animation

on:
  schedule: # execute every 12 hours
    - cron: "* */12 * * *"

  workflow_dispatch:

  push:
    branches:
    - main

jobs:
  generate:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: generate snake.svg
        uses: Platane/snk/svg-only@v3
        with:
          github_user_name: ${{ github.repository_owner }}
          outputs: dist/snake.svg?palette=github-dark


      - name: push snake.svg to the output branch
        uses: crazy-max/ghaction-github-pages@v3.1.0
        with:
          target_branch: output
          build_dir: dist
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path="js/index.js">
import init from "../pkg/portfolio.js";
import { Terminal3D } from "./model.js";

init().then(() => {
  console.log("Portfolio loaded successfully!");
});

document.addEventListener("DOMContentLoaded", () => {
  setTimeout(() => {
    window.terminal3d = new Terminal3D();
  }, 1000);
});

window.addEventListener("beforeunload", () => {
  if (window.terminal3d) {
    window.terminal3d.dispose();
  }
});
</file>

<file path="src/boot/boot.rs">
use crate::terminal::{renderer::LineOptions, Terminal};

pub async fn boot(term: &Terminal) {
    let boot_messages = vec![
        (
            "Loading Linux kernel version 6.8.9-arch1-1...",
            "[OK]",
            "green",
        ),
        ("Loading initial ramdisk (initramfs)...", "[OK]", "green"),
        ("Starting systemd-udevd v254.5-1...", "[OK]", "green"),
        ("Probing hardware...", "[OK]", "green"),
        ("Detected storage device: /dev/nvme0n1", "[OK]", "green"),
        ("Detected storage device: /dev/sda", "[OK]", "green"),
        ("Started udev Kernel Device Manager.", "[OK]", "green"),
        ("Activating swap on /dev/sda2...", "[OK]", "green"),
        ("Mounting root filesystem...", "[OK]", "green"),
        ("Checking file system on /dev/sda1...", "[OK]", "green"),
        ("Mounting /boot...", "[OK]", "green"),
        ("Mounting /home...", "[OK]", "green"),
        ("Mounting /var...", "[OK]", "green"),
        ("Starting systemd-journald.service...", "[OK]", "green"),
        (
            "Starting systemd-tmpfiles-setup-dev.service...",
            "[OK]",
            "green",
        ),
        ("Starting systemd-sysctl.service...", "[OK]", "green"),
        ("Starting Load Kernel Modules...", "[OK]", "green"),
        ("Loading kernel modules: i915 ext4 fuse...", "[OK]", "green"),
        (
            "Started Rule-based Manager for Device Events and Filesystems.",
            "[OK]",
            "green",
        ),
        ("Starting Network Manager...", "[OK]", "green"),
        ("Started Network Time Synchronization.", "[OK]", "green"),
        (
            "Starting Login Service (systemd-logind)...",
            "[OK]",
            "green",
        ),
        (
            "Starting Authorization Manager (polkitd)...",
            "[OK]",
            "green",
        ),
        ("Starting User Manager for UID 1000...", "[OK]", "green"),
        ("Started Getty on tty1.", "[OK]", "green"),
        ("Reached target Multi-User System.", "[OK]", "green"),
        ("Starting Interface...", "[OK]", "green"),
    ];

    for (msg, _status, color) in boot_messages {
        term.add_line(
            msg,
            Some(LineOptions::new().with_boot_animation().with_color(color)),
        )
        .await;
        term.sleep(15).await;
    }
    term.add_line("", None).await;
    term.add_line(
        "Started objz Terminal",
        Some(LineOptions::new().with_boot_animation().with_color("green")),
    )
    .await;
    term.sleep(200).await;
    term.add_line("", None).await;
}

pub async fn logo(term: &Terminal) {
    let logo_lines = vec![
        "                                                    ",
        " â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘       â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ ",
        "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘",
        "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘      â–‘â–’â–“â–ˆâ–“â–’â–‘    â–‘â–’â–“â–ˆâ–ˆâ–“â–’â–‘ ",
        "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘       â–‘â–’â–“â–ˆâ–“â–’â–‘  â–‘â–’â–“â–ˆâ–ˆâ–“â–’â–‘   ",
        "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–“â–’â–‘     ",
        "â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–“â–’â–‘â–’â–“â–ˆâ–“â–’â–‘       ",
        " â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘ â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘â–‘â–’â–“â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–“â–’â–‘",
        "                                                    ",
    ];

    for line in logo_lines {
        term.add_line(
            line,
            Some(LineOptions::new().with_typing(10).with_color("cyan")),
        )
        .await;
        term.sleep(30).await;
    }
}

pub async fn login(term: &Terminal) {
    let login_messages = vec![
        ("Arch Linux 6.6.32-1-lts (tty1)", "", "green"),
        ("", "", ""),
        ("login: anonym", "", "white"),
        ("password: ", "", "white"),
        ("", "", ""),
        ("Last login: Mon May 27 13:59:36 2025", "", "white"),
        ("Type 'help' for further information", "", "yellow"),
        ("", "", ""),
    ];

    for (msg, _status, color) in login_messages {
        if msg.is_empty() {
            term.add_line("", None).await;
        } else if msg.contains("login:") {
            term.add_line(msg, Some(LineOptions::new().with_typing(50)))
                .await;
        } else if msg.contains("password:") {
            let full = format!("{}â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢", msg);
            term.add_line(&full, Some(LineOptions::new().with_typing(50)))
                .await;
        } else {
            term.add_line(msg, Some(LineOptions::new().with_color(color)))
                .await;
        }
        term.sleep(60).await;
    }
}
</file>

<file path="src/terminal/autocomplete.rs">
pub struct AutoComplete {
    commands: Vec<String>,
}

impl AutoComplete {
    pub fn new() -> Self {
        let commands = vec![
            "help", "clear", "history", "echo", "date", "uptime", "neofetch", "uname", "ls", "ll",
            "cd", "cat", "pwd", "tree", "mkdir", "touch", "rm", "ln", "sudo", "cowsay", "sl",
            "lolcat", "calc",
        ]
        .into_iter()
        .map(|s| s.to_string())
        .collect();

        Self { commands }
    }

    pub fn complete(&mut self, input: &str, current_path: &[String]) -> CompletionResult {
        let trimmed = input.trim();
        if trimmed.is_empty() {
            return CompletionResult::None;
        }

        let parts: Vec<&str> = trimmed.split_whitespace().collect();

        if parts.len() == 1 {
            self.complete_command(&parts[0])
        } else {
            let command = parts[0];
            let partial_path = parts.last().map_or("", |v| v);

            match command {
                "cd" | "ls" | "cat" | "tree" | "rm" | "mkdir" | "touch" => {
                    self.complete_path(partial_path, current_path, command == "cd")
                }
                _ => CompletionResult::None,
            }
        }
    }

    fn complete_command(&self, partial: &str) -> CompletionResult {
        let matches: Vec<String> = self
            .commands
            .iter()
            .filter(|cmd| cmd.starts_with(partial))
            .cloned()
            .collect();

        match matches.len() {
            0 => CompletionResult::None,
            1 => CompletionResult::Single(matches[0].clone()),
            _ => CompletionResult::Multiple(matches),
        }
    }

    fn complete_path(
        &mut self,
        partial: &str,
        current_path: &[String],
        dirs_only: bool,
    ) -> CompletionResult {
        use crate::commands::filesystem::{get_filesystem_entries, normalize_path};

        let (dir_path, filename_prefix) = if partial.contains('/') {
            let last_slash = partial.rfind('/').unwrap();
            (&partial[..last_slash + 1], &partial[last_slash + 1..])
        } else {
            ("", partial)
        };

        let search_path = if dir_path.is_empty() {
            current_path.to_vec()
        } else {
            normalize_path(dir_path, current_path)
        };

        let entries = get_filesystem_entries(&search_path, dirs_only);

        let matches: Vec<String> = entries
            .into_iter()
            .filter(|entry| entry.starts_with(filename_prefix))
            .map(|entry| {
                if dir_path.is_empty() {
                    entry
                } else {
                    format!("{}{}", dir_path, entry)
                }
            })
            .collect();

        match matches.len() {
            0 => CompletionResult::None,
            1 => CompletionResult::Single(matches[0].clone()),
            _ => CompletionResult::Multiple(matches),
        }
    }
}

#[derive(Debug)]
pub enum CompletionResult {
    None,
    Single(String),
    Multiple(Vec<String>),
}

pub fn find_common_prefix(strings: &[String]) -> Option<String> {
    if strings.is_empty() {
        return None;
    }

    let first = &strings[0];
    let mut prefix = String::new();

    for (i, ch) in first.chars().enumerate() {
        if strings.iter().all(|s| s.chars().nth(i) == Some(ch)) {
            prefix.push(ch);
        } else {
            break;
        }
    }

    if prefix.is_empty() {
        None
    } else {
        Some(prefix)
    }
}
</file>

<file path="src/terminal/line_buffer.rs">
use std::cell::RefCell;
use std::collections::VecDeque;

/// Represents different types of terminal lines for proper rendering and management
#[derive(Debug, Clone, PartialEq)]
pub enum LineType {
    Normal,  // Regular output
    Command, // User command with prompt
    Output,  // Command output
    Boot,    // Boot sequence lines
    Typing,  // Typing animation lines
    Prompt,  // Standalone prompt
    Error,   // Error messages
    System,  // System messages
}

/// A single line in the terminal buffer with all its properties
#[derive(Debug, Clone)]
pub struct BufferLine {
    pub content: String,
    pub line_type: LineType,
    pub color: Option<String>,
    pub timestamp: f64,
    pub wrapped_lines: Vec<String>, // For handling long lines
}

impl BufferLine {
    pub fn new(content: String, line_type: LineType, color: Option<String>) -> Self {
        Self {
            content,
            line_type,
            color,
            timestamp: js_sys::Date::now(),
            wrapped_lines: Vec::new(),
        }
    }

    /// Calculate wrapped lines based on terminal width (Unicode-safe)
    pub fn calculate_wrapping(&mut self, max_width: usize) {
        self.wrapped_lines.clear();

        // Use char count instead of byte count for Unicode safety
        let chars: Vec<char> = self.content.chars().collect();

        if chars.len() <= max_width {
            self.wrapped_lines.push(self.content.clone());
            return;
        }

        let mut start = 0;
        while start < chars.len() {
            let end = (start + max_width).min(chars.len());

            if end >= chars.len() {
                // Last chunk
                let chunk: String = chars[start..].iter().collect();
                self.wrapped_lines.push(chunk);
                break;
            }

            // Find a good break point (prefer spaces) within character boundaries
            let mut break_point = end;
            for i in (start..end).rev() {
                if chars[i] == ' ' {
                    break_point = i;
                    break;
                }
            }

            let chunk: String = chars[start..break_point].iter().collect();
            self.wrapped_lines.push(chunk);

            // Skip the space if we broke on one
            start = if break_point < end && chars[break_point] == ' ' {
                break_point + 1
            } else {
                break_point
            };
        }
    }

    /// Get the number of visual lines this buffer line occupies
    pub fn visual_line_count(&self) -> usize {
        if self.wrapped_lines.is_empty() {
            1
        } else {
            self.wrapped_lines.len()
        }
    }
}

/// Terminal state for managing input and cursor
#[derive(Debug, Clone)]
pub struct TerminalState {
    pub current_input: String,
    pub cursor_position: usize,
    pub prompt: String,
    pub input_mode: InputMode,
    pub scroll_offset: usize,
}

#[derive(Debug, Clone, PartialEq)]
pub enum InputMode {
    Normal,     // Ready for input
    Processing, // Command being processed
    Disabled,   // Input disabled (e.g., during animations)
}

impl Default for TerminalState {
    fn default() -> Self {
        Self {
            current_input: String::new(),
            cursor_position: 0,
            prompt: "objz@objz:~$ ".to_string(),
            input_mode: InputMode::Normal,
            scroll_offset: 0,
        }
    }
}

/// Main line buffer implementation
pub struct LineBuffer {
    buffer: RefCell<VecDeque<BufferLine>>,
    state: RefCell<TerminalState>,
    max_lines: RefCell<usize>,
    terminal_width: RefCell<usize>,
    terminal_height: RefCell<usize>,
}

impl LineBuffer {
    pub fn new() -> Self {
        Self {
            buffer: RefCell::new(VecDeque::new()),
            state: RefCell::new(TerminalState::default()),
            max_lines: RefCell::new(1000), // Keep more history
            terminal_width: RefCell::new(80),
            terminal_height: RefCell::new(25),
        }
    }

    pub fn set_dimensions(&self, width: usize, height: usize) {
        *self.terminal_width.borrow_mut() = width;
        *self.terminal_height.borrow_mut() = height;

        let width_copy = width;
        let mut buffer = self.buffer.borrow_mut();
        for line in buffer.iter_mut() {
            line.calculate_wrapping(width_copy);
        }
    }

    pub fn add_line(&self, content: String, line_type: LineType, color: Option<String>) {
        let mut line = BufferLine::new(content, line_type, color);
        let width = *self.terminal_width.borrow();
        line.calculate_wrapping(width);

        let mut buffer = self.buffer.borrow_mut();
        buffer.push_back(line);

        let max = *self.max_lines.borrow();
        while buffer.len() > max {
            buffer.pop_front();
        }
    }

    pub fn add_lines(&self, content: &str, line_type: LineType, color: Option<String>) {
        for line in content.lines() {
            self.add_line(line.to_string(), line_type.clone(), color.clone());
        }
    }

    pub fn add_command(&self, prompt: &str, input: &str) {
        let full_command = format!("{}{}", prompt, input);
        self.add_line(full_command, LineType::Command, Some("cyan".to_string()));
    }

    pub fn clear(&self) {
        self.buffer.borrow_mut().clear();
        self.reset_scroll();
    }

    pub fn get_visible_lines(&self, max_visual_lines: usize) -> Vec<BufferLine> {
        let buffer = self.buffer.borrow();
        let state = self.state.borrow();

        let mut visual_lines = Vec::new();
        let mut total_visual_count = 0;

        for line in buffer.iter().rev() {
            let line_visual_count = line.visual_line_count();
            if total_visual_count + line_visual_count > max_visual_lines + state.scroll_offset {
                break;
            }
            visual_lines.insert(0, line.clone());
            total_visual_count += line_visual_count;
        }

        visual_lines
    }

    pub fn update_input(&self, input: String, cursor_pos: usize) {
        let mut state = self.state.borrow_mut();
        state.current_input = input;
        state.cursor_position = cursor_pos.min(state.current_input.chars().count());
    }

    pub fn set_prompt(&self, prompt: String) {
        self.state.borrow_mut().prompt = prompt;
    }

    fn get_state(&self) -> TerminalState {
        self.state.borrow().clone()
    }

    pub fn set_input_mode(&self, mode: InputMode) {
        self.state.borrow_mut().input_mode = mode;
    }

    pub fn reset_scroll(&self) {
        self.state.borrow_mut().scroll_offset = 0;
    }

    pub fn should_auto_scroll(&self) -> bool {
        let state = self.state.borrow();
        state.scroll_offset == 0
    }

    pub fn auto_scroll_to_bottom(&self) {
        if self.should_auto_scroll() {
            self.reset_scroll();
        }
    }
}

thread_local! {
    pub static LINE_BUFFER: LineBuffer = LineBuffer::new();
}

pub fn add_line(content: String, line_type: LineType, color: Option<String>) {
    LINE_BUFFER.with(|buffer| buffer.add_line(content, line_type, color));
}

pub fn add_command_line(prompt: &str, input: &str) {
    LINE_BUFFER.with(|buffer| buffer.add_command(prompt, input));
}

pub fn add_output_lines(output: &str, color: Option<String>) {
    LINE_BUFFER.with(|buffer| buffer.add_lines(output, LineType::Output, color));
}

pub fn clear_buffer() {
    LINE_BUFFER.with(|buffer| buffer.clear());
}

pub fn set_terminal_dimensions(width: usize, height: usize) {
    LINE_BUFFER.with(|buffer| buffer.set_dimensions(width, height));
}

pub fn get_visible_lines(max_lines: usize) -> Vec<BufferLine> {
    LINE_BUFFER.with(|buffer| buffer.get_visible_lines(max_lines))
}

pub fn update_input_state(input: String, cursor_pos: usize) {
    LINE_BUFFER.with(|buffer| buffer.update_input(input, cursor_pos));
}

pub fn set_current_prompt(prompt: String) {
    LINE_BUFFER.with(|buffer| buffer.set_prompt(prompt));
}

pub fn get_terminal_state() -> TerminalState {
    LINE_BUFFER.with(|buffer| buffer.get_state())
}

pub fn set_input_mode(mode: InputMode) {
    LINE_BUFFER.with(|buffer| buffer.set_input_mode(mode));
}

pub fn auto_scroll_to_bottom() {
    LINE_BUFFER.with(|buffer| buffer.auto_scroll_to_bottom());
}
</file>

<file path="src/utils/mod.rs">
pub mod panic;
</file>

<file path="build.sh">
#!/bin/zsh
wasm-pack build --target web --out-dir pkg
rm -rf dist 
mkdir -p dist/js
mkdir -p dist/style
cp -r static/* dist/
cp -r style/* dist/style/
cp -r js/* dist/js/
cp -r pkg dist/
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Install wasm-pack
        run: |
          curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      - name: Build WASM
        run: |
          wasm-pack build --target web --out-dir pkg

      - name: Prepare static site
        run: |
          mkdir -p dist/js
          mkdir -p dist/style
          cp -r static/* dist/
          cp -r style/* dist/style/
          cp -r js/* dist/js/
          cp -r pkg dist/

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist
</file>

<file path="src/boot/mod.rs">
use crate::terminal::Terminal;

pub mod boot;

impl Terminal {
    pub async fn init_boot(&self) {
        self.clear_output();
        boot::boot(self).await;
        boot::logo(self).await;
        boot::login(self).await;
        self.prepare_for_input();
    }
}
</file>

<file path="src/utils/panic.rs">
use crate::terminal::line_buffer::InputMode;
use crate::terminal::{line_buffer, Terminal};
use crate::utils::panic::line_buffer::LineType;

pub async fn trigger(terminal: &Terminal) {
    line_buffer::clear_buffer();
    line_buffer::set_input_mode(InputMode::Disabled);

    let panic_lines = vec![
        ("âš ï¸  CRITICAL SYSTEM ERROR âš ï¸", Some("error")),
        ("", None),
        ("Deleting root filesystem...", Some("warning")),
        ("rm: removing /usr... â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 75%", Some("warning")),
        ("rm: removing /var... â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 87%", Some("warning")),
        (
            "rm: removing /etc... â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%",
            Some("warning"),
        ),
        ("", None),
        ("SYSTEM DESTROYED â˜ ï¸", Some("error")),
        ("", None),
        (
            "Just kidding! This is a just website, not your actual system.",
            Some("success"),
        ),
        ("Nice try though! ðŸ˜‰", Some("success")),
        ("", None),
        (
            "(Don't actually run 'sudo rm -rf /' on real systems!)",
            Some("warning"),
        ),
    ];

    for (line, color) in panic_lines {
        line_buffer::add_line(
            line.to_string(),
            LineType::System,
            color.map(|s| s.to_string()),
        );
        terminal.render();
        terminal.sleep(500).await;
    }

    terminal.sleep(2000).await;

    line_buffer::clear_buffer();
    line_buffer::add_line(
        "System restored! Terminal is back online.".to_string(),
        LineType::System,
        Some("success".to_string()),
    );
    line_buffer::add_line("".to_string(), LineType::Normal, None);
    terminal.render();
}

pub fn should_panic(input: &str) -> bool {
    let parts: Vec<&str> = input.split_whitespace().collect();

    if parts.len() >= 4 && parts[0] == "sudo" && parts[1] == "rm" {
        let has_rf_flag = parts.iter().any(|&part| {
            part == "-rf" || part == "-fr" || part.contains("rf") || part.contains("fr")
        });

        if has_rf_flag {
            for &part in &parts[3..] {
                match part {
                    "/" => return true,
                    "./" => {
                        use crate::commands::filesystem::CURRENT_PATH;
                        let current_path = CURRENT_PATH.lock().unwrap();
                        if current_path.is_empty() {
                            return true;
                        }
                    }
                    path if path.starts_with("./") => {
                        use crate::commands::filesystem::CURRENT_PATH;
                        let current_path = CURRENT_PATH.lock().unwrap();
                        if current_path.is_empty() {
                            return true;
                        }
                    }
                    _ => {}
                }
            }
        }
    }

    false
}
</file>

<file path=".gitignore">
/target
**/*.rs.bk
Cargo.lock
bin/
pkg/
dist/
target/
wasm-pack.log
# repomix-output.xml
</file>

<file path="serve.sh">
#!/bin/zsh
./build.sh
npx serve dist
</file>

<file path="src/commands/filesystem.rs">
use lazy_static::lazy_static;
use std::collections::HashMap;
use std::sync::Mutex;

#[derive(Clone, Debug)]
pub enum Node {
    File {
        content: String,
        permissions: u16,
        owner: String,
        protected: bool,
    },
    Directory {
        children: HashMap<String, Node>,
        permissions: u16,
        owner: String,
        protected: bool,
    },
    Symlink {
        target: String,
        owner: String,
    },
}

impl Node {
    fn _is_directory(&self) -> bool {
        matches!(self, Node::Directory { .. })
    }

    fn _is_file(&self) -> bool {
        matches!(self, Node::File { .. })
    }

    fn is_protected(&self) -> bool {
        match self {
            Node::File { protected, .. } => *protected,
            Node::Directory { protected, .. } => *protected,
            Node::Symlink { .. } => false,
        }
    }

    fn get_owner(&self) -> &str {
        match self {
            Node::File { owner, .. } => owner,
            Node::Directory { owner, .. } => owner,
            Node::Symlink { owner, .. } => owner,
        }
    }
}

lazy_static! {
    pub static ref FILESYSTEM: Mutex<Node> = Mutex::new({
        use Node::*;
        Directory {
            permissions: 0o755,
            owner: "root".to_string(),
            protected: true,
            children: HashMap::from([
                (
                    "home".into(),
                    Directory {
                        permissions: 0o755,
                        owner: "root".to_string(),
                        protected: false,
                        children: HashMap::from([(
                            "objz".into(),
                            Directory {
                                permissions: 0o755,
                                owner: "objz".to_string(),
                                protected: false,
                                children: HashMap::from([
                                    (
                                        "projects".into(),
                                        Directory {
                                            permissions: 0o755,
                                            owner: "objz".to_string(),
                                            protected: true, // Protected!
                                            children: HashMap::from([(
                                                "readme.md".into(),
                                                File {
                                                    content: "# Projects\n\nThis is the projects folder.\nContains all my development work.".into(),
                                                    permissions: 0o644,
                                                    owner: "objz".to_string(),
                                                    protected: true,
                                                }
                                            )]),
                                        }
                                    ),
                                    (
                                        "about.txt".into(),
                                        File {
                                            content: "I'm objz â€“ a developer from Bavaria.\nI love Rust and WebAssembly!".into(),
                                            permissions: 0o644,
                                            owner: "objz".to_string(),
                                            protected: true, // Protected!
                                        }
                                    ),
                                    (
                                        "contact.txt".into(),
                                        File {
                                            content: "Email: me@objz.dev\nGitHub: @objz\nLocation: Bavaria, Germany".into(),
                                            permissions: 0o644,
                                            owner: "objz".to_string(),
                                            protected: true, // Protected!
                                        }
                                    ),
                                    (
                                        ".bashrc".into(),
                                        File {
                                            content: "# ~/.bashrc\nexport PS1='\\u@\\h:\\w\\$ '\nalias ll='ls -la'".into(),
                                            permissions: 0o644,
                                            owner: "objz".to_string(),
                                            protected: false,
                                        }
                                    ),
                                ]),
                            }
                        )]),
                    }
                ),
                (
                    "etc".into(),
                    Directory {
                        permissions: 0o755,
                        owner: "root".to_string(),
                        protected: true, // Protected!
                        children: HashMap::from([(
                            "hostname".into(),
                            File {
                                content: "wasm-host".into(),
                                permissions: 0o644,
                                owner: "root".to_string(),
                                protected: true,
                            }
                        )]),
                    }
                ),
                (
                    "tmp".into(),
                    Directory {
                        permissions: 0o1777,
                        owner: "root".to_string(),
                        protected: false,
                        children: HashMap::new(),
                    }
                ),
                (
                    "usr".into(),
                    Directory {
                        permissions: 0o755,
                        owner: "root".to_string(),
                        protected: true,
                        children: HashMap::from([(
                            "bin".into(),
                            Directory {
                                permissions: 0o755,
                                owner: "root".to_string(),
                                protected: true,
                                children: HashMap::new(),
                            }
                        )]),
                    }
                ),
            ])
        }
    });
    pub static ref CURRENT_PATH: Mutex<Vec<String>> = Mutex::new(vec!["home".to_string(), "objz".to_string()]);
    static ref CURRENT_USER: String = "anonym".to_string();
}

pub fn get_filesystem_entries(path: &[String], dirs_only: bool) -> Vec<String> {
    let filesystem = FILESYSTEM.lock().unwrap();

    match get_node_at_path(&filesystem, path) {
        Some(Node::Directory { children, .. }) => {
            let mut entries: Vec<String> = children
                .iter()
                .filter_map(|(name, node)| {
                    if dirs_only {
                        match node {
                            Node::Directory { .. } => Some(format!("{}/", name)),
                            _ => None,
                        }
                    } else {
                        match node {
                            Node::Directory { .. } => Some(format!("{}/", name)),
                            Node::File { .. } => Some(name.clone()),
                            Node::Symlink { .. } => Some(format!("{}@", name)),
                        }
                    }
                })
                .collect();

            entries.sort();
            entries
        }
        _ => Vec::new(),
    }
}

pub fn normalize_path(path: &str, current: &[String]) -> Vec<String> {
    if path.starts_with('/') {
        let mut result = Vec::new();
        for part in path.split('/').filter(|s| !s.is_empty()) {
            match part {
                "." => continue,
                ".." => {
                    result.pop();
                }
                _ => result.push(part.to_string()),
            }
        }
        result
    } else {
        let mut result = current.to_vec();
        for part in path.split('/').filter(|s| !s.is_empty()) {
            match part {
                "." => continue,
                ".." => {
                    result.pop();
                }
                _ => result.push(part.to_string()),
            }
        }
        result
    }
}

pub fn get_node_at_path<'a>(root: &'a Node, path: &[String]) -> Option<&'a Node> {
    let mut current = root;
    for part in path {
        if let Node::Directory { children, .. } = current {
            current = children.get(part)?;
        } else {
            return None;
        }
    }
    Some(current)
}

fn get_node_at_path_mut<'a>(root: &'a mut Node, path: &[String]) -> Option<&'a mut Node> {
    let mut current = root;
    for part in path {
        if let Node::Directory { children, .. } = current {
            current = children.get_mut(part)?;
        } else {
            return None;
        }
    }
    Some(current)
}

pub fn ls(args: &[&str]) -> String {
    let filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();

    let mut show_hidden = false;
    let mut long_format = false;
    let mut target_path = None;

    for arg in args {
        if arg.starts_with('-') {
            for c in arg.chars().skip(1) {
                match c {
                    'a' => show_hidden = true,
                    'l' => long_format = true,
                    _ => return format!("ls: invalid option -- '{}'", c),
                }
            }
        } else {
            target_path = Some(*arg);
        }
    }

    let path = if let Some(target) = target_path {
        normalize_path(target, &current_path)
    } else {
        current_path.clone()
    };

    let node = match get_node_at_path(&filesystem, &path) {
        Some(node) => node,
        None => return "ls: cannot access: No such file or directory".into(),
    };

    match node {
        Node::Directory { children, .. } => {
            let mut entries: Vec<_> = children.iter().collect();
            entries.sort_by_key(|(name, _)| name.as_str());

            if long_format {
                let mut output = String::new();
                for (name, node) in &entries {
                    if !show_hidden && name.starts_with('.') {
                        continue;
                    }

                    let (file_type, permissions, size) = match node {
                        Node::Directory { permissions, .. } => ('d', *permissions, 4096),
                        Node::File {
                            permissions,
                            content,
                            ..
                        } => ('-', *permissions, content.len()),
                        Node::Symlink { .. } => ('l', 0o777, 0),
                    };

                    output.push_str(&format!(
                        "{}{:o} 1 objz objz {:>8} {} {}\n",
                        file_type, permissions, size, "Jan  1 12:00", name
                    ));
                }
                output
            } else {
                entries
                    .iter()
                    .filter(|(name, _)| show_hidden || !name.starts_with('.'))
                    .map(|(name, node)| match node {
                        Node::Directory { .. } => format!("{}/", name),
                        Node::File { .. } => name.to_string(),
                        Node::Symlink { .. } => format!("{}@", name),
                    })
                    .collect::<Vec<_>>()
                    .join("  ")
            }
        }
        Node::File { .. } => target_path.unwrap_or(".").to_string(),
        Node::Symlink { target, .. } => format!("-> {}", target),
    }
}

pub fn cd(args: &[&str]) -> String {
    if args.is_empty() {
        {
            let mut path = CURRENT_PATH.lock().unwrap();
            *path = vec!["home".to_string(), "objz".to_string()];
        }
        return String::new();
    }

    let new_path = {
        let filesystem = FILESYSTEM.lock().unwrap();
        let current_path = CURRENT_PATH.lock().unwrap();

        let new_path = normalize_path(args[0], &current_path);

        match get_node_at_path(&filesystem, &new_path) {
            Some(Node::Directory { .. }) => new_path,
            Some(Node::Symlink { target, .. }) => {
                let symlink_path = normalize_path(target, &current_path);
                match get_node_at_path(&filesystem, &symlink_path) {
                    Some(Node::Directory { .. }) => symlink_path,
                    Some(_) => return format!("cd: {}: Not a directory", args[0]),
                    None => return format!("cd: {}: No such file or directory", args[0]),
                }
            }
            Some(_) => return format!("cd: {}: Not a directory", args[0]),
            None => return format!("cd: {}: No such file or directory", args[0]),
        }
    };

    {
        let mut path = CURRENT_PATH.lock().unwrap();
        *path = new_path;
    }
    String::new()
}

pub fn pwd(_: &[&str]) -> String {
    let path = CURRENT_PATH.lock().unwrap();
    if path.is_empty() {
        "/".into()
    } else {
        format!("/{}", path.join("/"))
    }
}

pub fn cat(args: &[&str]) -> String {
    if args.is_empty() {
        return "cat: missing file operand".into();
    }

    let filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();

    let mut output = String::new();

    for &filename in args {
        let file_path = normalize_path(filename, &current_path);

        match get_node_at_path(&filesystem, &file_path) {
            Some(Node::File { content, .. }) => {
                output.push_str(content);
                if args.len() > 1 && filename != args[args.len() - 1] {
                    output.push('\n');
                }
            }
            Some(Node::Directory { .. }) => {
                output.push_str(&format!("cat: {}: Is a directory\n", filename));
            }
            Some(Node::Symlink { target, .. }) => {
                output.push_str(&format!(
                    "cat: {}: Symbolic link (points to {})\n",
                    filename, target
                ));
            }
            None => {
                output.push_str(&format!("cat: {}: No such file or directory\n", filename));
            }
        }
    }

    output.trim_end().to_string()
}

pub fn mkdir(args: &[&str]) -> String {
    if args.is_empty() {
        return "mkdir: missing operand".into();
    }

    let mut filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();
    let current_user = &*CURRENT_USER;

    for &dirname in args {
        let dir_path = normalize_path(dirname, &current_path);

        if dir_path.is_empty() {
            return "mkdir: cannot create directory '/': File exists".into();
        }

        let parent_path = &dir_path[..dir_path.len() - 1];
        let dir_name = &dir_path[dir_path.len() - 1];

        let parent = match get_node_at_path_mut(&mut filesystem, parent_path) {
            Some(Node::Directory { children, .. }) => children,
            Some(_) => {
                return format!(
                    "mkdir: cannot create directory '{}': Not a directory",
                    dirname
                )
            }
            None => {
                return format!(
                    "mkdir: cannot create directory '{}': No such file or directory",
                    dirname
                )
            }
        };

        if parent.contains_key(dir_name) {
            return format!("mkdir: cannot create directory '{}': File exists", dirname);
        }

        parent.insert(
            dir_name.clone(),
            Node::Directory {
                permissions: 0o755,
                owner: current_user.clone(),
                protected: false,
                children: HashMap::new(),
            },
        );
    }

    String::new()
}

pub fn touch(args: &[&str]) -> String {
    if args.is_empty() {
        return "touch: missing file operand".into();
    }

    let mut filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();
    let current_user = &*CURRENT_USER;

    for &filename in args {
        let file_path = normalize_path(filename, &current_path);

        if file_path.is_empty() {
            continue;
        }

        let parent_path = &file_path[..file_path.len() - 1];
        let file_name = &file_path[file_path.len() - 1];

        let parent = match get_node_at_path_mut(&mut filesystem, parent_path) {
            Some(Node::Directory { children, .. }) => children,
            Some(_) => return format!("touch: cannot touch '{}': Not a directory", filename),
            None => {
                return format!(
                    "touch: cannot touch '{}': No such file or directory",
                    filename
                )
            }
        };

        if !parent.contains_key(file_name) {
            parent.insert(
                file_name.clone(),
                Node::File {
                    content: String::new(),
                    permissions: 0o644,
                    owner: current_user.clone(),
                    protected: false,
                },
            );
        }
    }

    String::new()
}

pub fn rm(args: &[&str]) -> String {
    if args.is_empty() {
        return "rm: missing operand".into();
    }

    let mut filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();
    let current_user = &*CURRENT_USER;

    let mut recursive = false;
    let mut force = false;
    let mut files = Vec::new();

    for &arg in args {
        if arg.starts_with('-') {
            for c in arg.chars().skip(1) {
                match c {
                    'r' | 'R' => recursive = true,
                    'f' => force = true,
                    _ => return format!("rm: invalid option -- '{}'", c),
                }
            }
        } else {
            files.push(arg);
        }
    }

    for filename in files {
        let file_path = normalize_path(filename, &current_path);

        if file_path.is_empty() {
            if !force {
                return "rm: cannot remove '/': Permission denied".into();
            }
            continue;
        }

        let parent_path = &file_path[..file_path.len() - 1];
        let file_name = &file_path[file_path.len() - 1];

        let parent = match get_node_at_path_mut(&mut filesystem, parent_path) {
            Some(Node::Directory { children, .. }) => children,
            Some(_) => {
                if !force {
                    return format!("rm: cannot remove '{}': Not a directory", filename);
                }
                continue;
            }
            None => {
                if !force {
                    return format!(
                        "rm: cannot remove '{}': No such file or directory",
                        filename
                    );
                }
                continue;
            }
        };

        match parent.get(file_name) {
            Some(node) => {
                if node.is_protected() {
                    return format!(
                        "rm: cannot remove '{}': Operation not permitted (protected system file)",
                        filename
                    );
                }

                if node.get_owner() != current_user && current_user != "root" {
                    return format!(
                        "rm: cannot remove '{}': Permission denied (not owner)",
                        filename
                    );
                }

                match node {
                    Node::Directory { .. } => {
                        if !recursive {
                            if !force {
                                return format!("rm: cannot remove '{}': Is a directory", filename);
                            }
                            continue;
                        }
                        parent.remove(file_name);
                    }
                    Node::File { .. } | Node::Symlink { .. } => {
                        parent.remove(file_name);
                    }
                }
            }
            None => {
                if !force {
                    return format!(
                        "rm: cannot remove '{}': No such file or directory",
                        filename
                    );
                }
            }
        }
    }

    String::new()
}

pub fn tree(args: &[&str]) -> String {
    let filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();

    let start_path = if args.is_empty() {
        current_path.clone()
    } else {
        normalize_path(args[0], &current_path)
    };

    let start_node = match get_node_at_path(&filesystem, &start_path) {
        Some(node) => node,
        None => return "tree: No such file or directory".into(),
    };

    fn build_tree(node: &Node, prefix: &str, _is_last: bool) -> String {
        let mut output = String::new();

        if let Node::Directory { children, .. } = node {
            let mut entries: Vec<_> = children.iter().collect();
            entries.sort_by_key(|(name, _)| name.as_str());

            for (i, (name, child)) in entries.iter().enumerate() {
                let is_last_child = i == entries.len() - 1;
                let connector = if is_last_child {
                    "â””â”€â”€ "
                } else {
                    "â”œâ”€â”€ "
                };

                let display_name = match child {
                    Node::Directory { .. } => format!("{}/", name),
                    Node::File { .. } => name.to_string(),
                    Node::Symlink { target, .. } => format!("{} -> {}", name, target),
                };

                output.push_str(&format!("{}{}{}\n", prefix, connector, display_name));

                let new_prefix =
                    format!("{}{}", prefix, if is_last_child { "    " } else { "â”‚   " });

                output.push_str(&build_tree(child, &new_prefix, is_last_child));
            }
        }

        output
    }

    let tree_name = if start_path.is_empty() {
        "/".to_string()
    } else {
        start_path.last().unwrap_or(&"/".to_string()).clone()
    };

    format!("{}\n{}", tree_name, build_tree(start_node, "", true))
}

pub fn ln(args: &[&str]) -> String {
    if args.len() < 2 {
        return "ln: missing file operand".into();
    }

    let mut filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();
    let current_user = &*CURRENT_USER;

    let (target, link_name) = if args[0] == "-s" {
        if args.len() < 3 {
            return "ln: missing file operand".into();
        }
        (args[1], args[2])
    } else {
        return "ln: hard links not supported in this filesystem".into();
    };

    let link_path = normalize_path(link_name, &current_path);

    if link_path.is_empty() {
        return "ln: cannot create link '/': File exists".into();
    }

    let parent_path = &link_path[..link_path.len() - 1];
    let file_name = &link_path[link_path.len() - 1];

    let parent = match get_node_at_path_mut(&mut filesystem, parent_path) {
        Some(Node::Directory { children, .. }) => children,
        Some(_) => return format!("ln: cannot create link '{}': Not a directory", link_name),
        None => {
            return format!(
                "ln: cannot create link '{}': No such file or directory",
                link_name
            )
        }
    };

    if parent.contains_key(file_name) {
        return format!("ln: cannot create link '{}': File exists", link_name);
    }

    parent.insert(
        file_name.clone(),
        Node::Symlink {
            target: target.to_string(),
            owner: current_user.clone(),
        },
    );

    String::new()
}

pub fn uname(args: &[&str]) -> String {
    if args.is_empty() || args[0] == "-s" {
        "WASM".to_string()
    } else if args[0] == "-a" {
        "WASM wasm-host 1.0.0 #1 SMP PREEMPT_DYNAMIC Mon Jan 1 12:00:00 UTC 2024 wasm32 GNU/Linux"
            .to_string()
    } else {
        "uname: invalid option".to_string()
    }
}
</file>

<file path="src/commands/misc.rs">
pub fn help(_args: &[&str]) -> String {
    r#"Available commands:

System Info:
  uname       - System information
  uptime      - System uptime
  neofetch    - Detailed system info
  date        - Current date and time

File System:
  ls, ll      - List directory contents
  cd          - Change directory
  pwd         - Print working directory
  cat         - Display file contents
  tree        - Display directory tree
  mkdir       - Create directory
  touch       - Create empty file
  rm          - Remove files/directories
  ln          - Create symbolic links

Utilities:
  clear       - Clear screen
  history     - Command history
  echo        - Display text
  cowsay      - ASCII cow with message
  sl          - Steam locomotive
  lolcat      - Rainbow text
  calc        - Calculator
  sudo        - Sudo access


Type `ls`, then `cd projects` and `ls` again.  
Run a project with `./project-name`.""#
        .to_string()
}

pub fn sudo(args: &[&str]) -> String {
    if args.len() >= 3 && args[0] == "rm" && args[1] == "-rf" && args[2] == "/" {
        "SYSTEM_PANIC".to_string()
    } else {
        "[sudo] password for objz: \n\nSorry, try again.\n[sudo] password for objz: \n\nSudo access denied for portfolio demo.".to_string()
    }
}

pub fn cowsay(args: &[&str]) -> String {
    let message = if args.is_empty() {
        "Hello from WASM!"
    } else {
        &args.join(" ")
    };

    let bubble_line = "-".repeat(message.len() + 2);

    format!(
        r#" {}
< {} >
 {}
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||"#,
        bubble_line, message, bubble_line
    )
}

pub fn sl(_args: &[&str]) -> String {
    r#"                 (@@) (  ) (@)  ( )  @@    ()    @     O     @     O      @
            (   )
        (@@@@)
     (    )

   (@@@)
====        ________                ___________
_D _|  |_______/        \__I_I_____===__|_________|
 |(_)---  |   H\________/ |   |        =|___ ___|      _________________
 /     |  |   H  |  |     |   |         ||_| |_||     _|                \_____A
|      |  |   H  |__--------------------| [___] |   =|                        |
| ________|___H__/__|_____/[][]~\_______|       |   -|                        |
|/ |   |-----------I_____I [][] []  D   |=======|____|________________________|_
__/ =| o |=-~O=====O=====O=====O\ ____Y___________|__|__________________________|_
 |/-=|___|=    ||    ||    ||    |_____/~\___/          |_D__D__D_|  |_D__D__D_|
  \_/      \__/  \__/  \__/  \__/      \_/               \_/   \_/    \_/   \_/

You have new mail."#
        .to_string()
}

pub fn lolcat(args: &[&str]) -> String {
    if args.is_empty() {
        "Usage: lolcat <text>".to_string()
    } else {
        format!("ðŸŒˆ {} ðŸŒˆ", args.join(" "))
    }
}

pub fn calc(args: &[&str]) -> String {
    if args.is_empty() {
        return "Usage: calc <expression>\nExample: calc 2 + 2".to_string();
    }

    let expression = args.join(" ");

    if let Some(result) = evaluate(&expression) {
        format!("{} = {}", expression, result)
    } else {
        format!("Error: Cannot evaluate '{}'", expression)
    }
}

fn evaluate(expr: &str) -> Option<f64> {
    let parts: Vec<&str> = expr.split_whitespace().collect();

    if parts.len() == 3 {
        if let (Ok(a), Ok(b)) = (parts[0].parse::<f64>(), parts[2].parse::<f64>()) {
            match parts[1] {
                "+" => Some(a + b),
                "-" => Some(a - b),
                "*" => Some(a * b),
                "/" if b != 0.0 => Some(a / b),
                _ => None,
            }
        } else {
            None
        }
    } else {
        None
    }
}
</file>

<file path="src/commands/processor.rs">
use crate::commands::{filesystem, system};

use super::misc;

#[derive(Clone)]
pub struct CommandHandler {
    history: Vec<String>,
}

impl CommandHandler {
    pub fn new() -> Self {
        Self {
            history: Vec::new(),
        }
    }

    pub fn get_current_directory(&self) -> String {
        filesystem::pwd(&[])
    }

    pub fn handle(&mut self, input: &str) -> (String, bool) {
        let trimmed = input.trim();
        if trimmed.is_empty() {
            return (String::new(), false);
        }

        self.history.push(trimmed.to_string());
        let parts: Vec<&str> = trimmed.split_whitespace().collect();
        let cmd = parts[0];
        let args = &parts[1..];

        let directory_changed = cmd == "cd";

        let output = match cmd {
            "clear" => system::clear(args),
            "history" => self.show_history(args),
            "echo" => system::echo(args),
            "date" => system::date(args),
            "uptime" => system::uptime(args),
            "neofetch" => system::neofetch(args),

            "ls" => filesystem::ls(args),
            "cd" => filesystem::cd(args),
            "cat" => filesystem::cat(args),
            "pwd" => filesystem::pwd(args),
            "tree" => filesystem::tree(args),
            "mkdir" => filesystem::mkdir(args),
            "touch" => filesystem::touch(args),
            "rm" => filesystem::rm(args),
            "uname" => filesystem::uname(args),
            "ln" => filesystem::ln(args),
            "ll" => filesystem::ls(&["-la"]),

            "help" => misc::help(args),
            "sudo" => misc::sudo(args),
            "cowsay" => misc::cowsay(args),
            "sl" => misc::sl(args),
            "lolcat" => misc::lolcat(args),
            "calc" => misc::calc(args),

            _ => format!("zsh: {}: command not found", cmd),
        };

        (output, directory_changed)
    }

    fn show_history(&self, _args: &[&str]) -> String {
        if self.history.is_empty() {
            "No commands in history yet.".to_string()
        } else {
            self.history
                .iter()
                .enumerate()
                .map(|(i, cmd)| format!("  {}  {}", i + 1, cmd))
                .collect::<Vec<_>>()
                .join("\n")
        }
    }
}
</file>

<file path="src/terminal/mod.rs">
pub mod autocomplete;
pub mod core;
pub mod line_buffer;
pub mod renderer;

pub use core::Terminal;
</file>

<file path="src/terminal/core.rs">
use super::line_buffer;
use super::renderer::{LineOptions, TerminalRenderer};
use crate::commands::CommandHandler;
use js_sys::Promise;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;
use web_sys::{window, CanvasRenderingContext2d, Document, HtmlCanvasElement};

#[derive(Clone)]
pub struct Terminal {
    pub renderer: TerminalRenderer,
    pub command_handler: CommandHandler,
    pub base_prompt: String,
}

impl Terminal {
    pub fn new(document: &Document) -> Self {
        let canvas = document
            .get_element_by_id("terminal")
            .expect("canvas not found")
            .dyn_into::<HtmlCanvasElement>()
            .expect("element is not a canvas");

        let canvas_width = 800;
        let canvas_height = 600;

        canvas.set_width(canvas_width);
        canvas.set_height(canvas_height);

        let context = canvas
            .get_context("2d")
            .expect("failed to get 2d context")
            .unwrap()
            .dyn_into::<CanvasRenderingContext2d>()
            .expect("failed to cast to CanvasRenderingContext2d");

        let renderer = TerminalRenderer::new(canvas, context);
        let command_handler = CommandHandler::new();
        let base_prompt = "objz@objz".to_string();

        line_buffer::set_terminal_dimensions(
            renderer.max_chars_per_line(),
            renderer.max_visible_lines(),
        );

        Self {
            renderer,
            command_handler,
            base_prompt,
        }
    }

    pub fn get_current_prompt(&self) -> String {
        let cwd = self.command_handler.get_current_directory();
        let display_path = if cwd == "/home/objz" {
            "~".to_string()
        } else if cwd.starts_with("/home/objz/") {
            format!("~{}", &cwd["/home/objz".len()..])
        } else {
            cwd
        };

        format!("{}:{}$ ", self.base_prompt, display_path)
    }

    pub async fn sleep(&self, ms: i32) {
        let promise = Promise::new(&mut |resolve, _reject| {
            let window = window().unwrap();
            let closure = Closure::once_into_js(move || {
                resolve.call0(&wasm_bindgen::JsValue::UNDEFINED).unwrap();
            });
            window
                .set_timeout_with_callback_and_timeout_and_arguments_0(
                    closure.as_ref().unchecked_ref(),
                    ms,
                )
                .unwrap();
        });

        let _ = JsFuture::from(promise).await;
    }

    pub async fn add_line(&self, text: &str, options: Option<LineOptions>) {
        self.renderer.add_line(text, options).await;
    }

    pub fn clear_output(&self) {
        self.renderer.clear_output();
    }

    pub fn prepare_for_input(&self) {
        let prompt = self.get_current_prompt();
        line_buffer::set_current_prompt(prompt);
        self.renderer.prepare_for_input();
    }

    pub fn render(&self) {
        self.renderer.render();
    }
}
</file>

<file path="js/model.js">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

export class Terminal3D {
  constructor() {
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.controls = null;
    this.pcModel = null;
    this.screenMesh = null;
    this.terminalTexture = null;
    this.terminalCanvas = null; // Add reference to terminal canvas
    this.hiddenInput = null; // Add reference to hidden input element
    this.isTerminalFocused = false;
    this.animationId = null;
    this.init();
  }

  async init() {
    try {
      this.updateLoadingProgress(10);
      await this.setupScene();
      this.updateLoadingProgress(30);
      await this.loadPCModel();
      this.updateLoadingProgress(60);
      await this.setupTerminalTexture();
      this.updateLoadingProgress(80);
      this.setupEventListeners();
      this.updateLoadingProgress(100);
      this.hideLoading();
      this.showTerminal();
      this.animate();
    } catch (e) {
      console.error("3D init failed:", e);
      this.showError();
    }
  }

  updateLoadingProgress(p) {
    const bar = document.getElementById("loading-progress");
    if (bar) bar.style.width = p + "%";
  }

  hideLoading() {
    setTimeout(() => {
      const L = document.getElementById("loading");
      if (L) L.classList.add("hidden");
    }, 500);
  }

  showError() {
    const txt = document.querySelector(".loading-text");
    if (txt) {
      txt.textContent = "Failed to load 3D. Showing terminal.";
      txt.style.color = "#ff5555";
    }
    setTimeout(() => {
      const L = document.getElementById("loading");
      if (L) L.classList.add("hidden");
      const term = document.getElementById("terminal");
      if (term) term.style.visibility = "visible";
    }, 2000);
  }

  showTerminal() {
    const terminal = document.getElementById("terminal");
    if (terminal) {
      terminal.style.visibility = "visible";
    }
  }

  async setupScene() {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x0a0a0a);
    this.camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      100,
    );
    this.camera.position.set(0, 1.5, 3);
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    document
      .getElementById("scene-container")
      .appendChild(this.renderer.domElement);
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.target.set(0, 1, 0);

    this.scene.add(new THREE.HemisphereLight(0x8be9fd, 0x444444, 0.3));
  }

  async loadPCModel() {
    console.log("Loading PC model...");
    return new Promise((resolve) => {
      const loader = new GLTFLoader();
      loader.load(
        "./pc.glb",
        (gltf) => {
          console.log("Model loaded");
          this.pcModel = gltf.scene;
          this.pcModel.scale.setScalar(1);
          this.pcModel.position.set(0, 0, 0);

          this.pcModel.traverse((c) => {
            if (c.isMesh) {
              c.castShadow = c.receiveShadow = true;
              const n = c.name.toLowerCase();
              const m = c.material?.name?.toLowerCase() || "";
              if (
                n.includes("screen") ||
                n.includes("monitor") ||
                m.includes("screen") ||
                m.includes("monitor") ||
                c.name === "Plane008_Material002_0"
              ) {
                this.screenMesh = c;
                console.log("Found screen:", c.name);
              }
            }
          });
          if (!this.screenMesh) {
            this.findScreenMesh();
          }
          this.scene.add(this.pcModel);
          resolve();
        },
        (prog) => {
          const pct = 30 + (prog.loaded / prog.total) * 30;
          this.updateLoadingProgress(pct);
        },
        (err) => {
          console.warn("Model load failed:", err);
          resolve();
        },
      );
    });
  }

  findScreenMesh() {
    const candidates = [];
    this.pcModel.traverse((c) => {
      if (c.isMesh && c.geometry) {
        const box = new THREE.Box3().setFromObject(c);
        const s = box.getSize(new THREE.Vector3());
        const flat = Math.min(s.x, s.y, s.z) < Math.max(s.x, s.y, s.z) * 0.1;
        const big = Math.max(s.x, s.y, s.z) > 0.5;
        if (flat && big) candidates.push({ mesh: c, area: s.x * s.y * s.z });
      }
    });
    if (candidates.length) {
      candidates.sort((a, b) => b.area - a.area);
      this.screenMesh = candidates[0].mesh;
    } else {
      this.pcModel.traverse((c) => {
        if (!this.screenMesh && c.isMesh) this.screenMesh = c;
      });
    }
  }

  async setupTerminalTexture() {
    // Get the terminal canvas directly (created by your Rust code)
    this.terminalCanvas = document.getElementById("terminal");
    // Get the hidden input element (used by Rust for input handling)
    this.hiddenInput = document.getElementById("hidden-input");

    if (!this.terminalCanvas) {
      console.error("Terminal canvas not found!");
      return;
    }

    if (!this.hiddenInput) {
      console.error("Hidden input element not found!");
      return;
    }

    // Wait a frame to ensure canvas is ready
    await new Promise((r) => requestAnimationFrame(r));

    // Create Three.js texture from the existing canvas
    this.terminalTexture = new THREE.CanvasTexture(this.terminalCanvas);
    this.terminalTexture.minFilter = THREE.LinearFilter;
    this.terminalTexture.magFilter = THREE.LinearFilter;
    this.terminalTexture.flipY = true; // Canvas is already correct orientation

    // Apply texture to screen mesh
    if (this.screenMesh) {
      this.screenMesh.material = new THREE.MeshBasicMaterial({
        map: this.terminalTexture,
        emissive: new THREE.Color(0x001a1a),
        emissiveIntensity: 0.1,
      });
    }

    // Adjust texture mapping if needed
    this.terminalTexture.offset.y = 0.0;
    this.terminalTexture.repeat.y = 1.0;

    // Set up automatic texture updates
    this.updateTerminalTexture = () => {
      try {
        // The canvas is automatically updated by your Rust terminal renderer
        // We just need to tell Three.js to update the texture
        if (this.terminalTexture) {
          this.terminalTexture.needsUpdate = true;
        }
      } catch (e) {
        console.warn("Texture update failed:", e);
      }
    };

    // Update texture regularly to sync with terminal changes
    setInterval(() => {
      this.updateTerminalTexture();
    }, 16); // ~60fps updates
  }

  setupEventListeners() {
    window.addEventListener("resize", () => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Set up raycasting for screen clicks
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();

    this.renderer.domElement.addEventListener("click", (event) => {
      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      this.raycaster.setFromCamera(this.mouse, this.camera);

      const intersectables = [];
      if (this.pcModel) {
        this.pcModel.traverse((child) => {
          if (child.isMesh) {
            intersectables.push(child);
          }
        });
      }
      if (this.screenMesh && !intersectables.includes(this.screenMesh)) {
        intersectables.push(this.screenMesh);
      }

      const intersects = this.raycaster.intersectObjects(intersectables);

      if (intersects.length > 0) {
        const clickedObject = intersects[0].object;
        console.log(
          "Clicked object:",
          clickedObject.name || "unnamed",
          clickedObject,
        );

        const isScreen =
          clickedObject.name === "Plane008_Material002_0" ||
          clickedObject === this.screenMesh ||
          clickedObject.material?.map === this.terminalTexture ||
          (clickedObject.name &&
            clickedObject.name.toLowerCase().includes("screen"));

        if (isScreen) {
          console.log("Screen clicked - focusing terminal input");
          this.isTerminalFocused = true;

          // Focus the hidden input element (this is what handles the actual input)
          if (this.hiddenInput) {
            this.hiddenInput.focus();
          }

          // Trigger any terminal focus events if your Rust code needs them
          const focusEvent = new CustomEvent("terminalFocus");
          window.dispatchEvent(focusEvent);
        } else {
          console.log("Clicked on non-screen object - removing focus");
          this.isTerminalFocused = false;

          // Blur the hidden input element
          if (this.hiddenInput) {
            this.hiddenInput.blur();
          }

          const blurEvent = new CustomEvent("terminalBlur");
          window.dispatchEvent(blurEvent);
        }
      } else {
        console.log("Clicked on empty space - removing focus");
        this.isTerminalFocused = false;

        // Blur the hidden input element
        if (this.hiddenInput) {
          this.hiddenInput.blur();
        }

        const blurEvent = new CustomEvent("terminalBlur");
        window.dispatchEvent(blurEvent);
      }
    });

    // Handle clicks outside the 3D scene
    document.addEventListener("click", (e) => {
      if (
        !e.target.closest("#scene-container") &&
        !e.target.closest("#terminal") &&
        !e.target.closest("#hidden-input")
      ) {
        console.log("Clicked outside - removing focus");
        this.isTerminalFocused = false;

        // Blur the hidden input element
        if (this.hiddenInput) {
          this.hiddenInput.blur();
        }

        const blurEvent = new CustomEvent("terminalBlur");
        window.dispatchEvent(blurEvent);
      }
    });

    // Listen for custom focus/blur events from Rust code if needed
    window.addEventListener("terminalFocus", () => {
      console.log("Terminal focus event received");
      this.isTerminalFocused = true;
      if (this.hiddenInput) {
        this.hiddenInput.focus();
      }
    });

    window.addEventListener("terminalBlur", () => {
      console.log("Terminal blur event received");
      this.isTerminalFocused = false;
      if (this.hiddenInput) {
        this.hiddenInput.blur();
      }
    });
  }

  animate() {
    this.animationId = requestAnimationFrame(() => this.animate());
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  dispose() {
    if (this.animationId) cancelAnimationFrame(this.animationId);
    if (this.renderer) this.renderer.dispose();
    if (this.terminalTexture) this.terminalTexture.dispose();
  }
}
</file>

<file path="Cargo.toml">
[package]
name = "portfolio"
version = "0.1.0"
authors = ["objz <me@objz.dev>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]

[dependencies]
wasm-bindgen = "0.2.84"
wasm-bindgen-futures = "0.4.37"
js-sys = "0.3.61"
console_error_panic_hook = { version = "0.1.7", optional = true }
lazy_static = "1.5.0"

[dependencies.web-sys]
version = "0.3.61"
features = [
  "console",
  "Document",
  "Element",
  "HtmlElement",
  "HtmlInputElement",
  "HtmlTextAreaElement",
  "KeyboardEvent",
  "Window",
  "EventTarget",
  "Event",
  "CssStyleDeclaration",
  "HtmlCanvasElement",
  "CanvasRenderingContext2d",
  "TextMetrics",
  "CustomEvent"
]

[profile.release]
opt-level = "s"
</file>

<file path="static/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>objz@portfolio:~$ _</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../style/styles.css" />
  </head>
  <body>
    <!-- Loading Screen -->
    <div id="loading">
      <div class="loading-text">Initializing...</div>
      <div class="loading-bar">
        <div class="loading-progress" id="loading-progress"></div>
      </div>
    </div>

    <div id="scene-container"></div>

    <canvas tabindex="0" id="terminal"></canvas>
    <input
      id="hidden-input"
      type="text"
      style="
        position: absolute;
        left: -9999px;
        top: -9999px;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
      "
      autocomplete="off"
      spellcheck="false"
    />

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module" src="../js/index.js"></script>
  </body>
</html>
</file>

<file path="src/lib.rs">
use input::setup::InputSetup;
use wasm_bindgen::prelude::*;
use web_sys::HtmlInputElement;

mod ascii_art;
mod boot;
mod commands;
mod input;
mod terminal;
mod utils;

use terminal::Terminal;

#[wasm_bindgen(start)]
pub fn main() {
    console_error_panic_hook::set_once();

    let window = web_sys::window().expect("no global `window` exists");
    let document = window.document().expect("should have a document on window");

    // Initialize system time
    commands::system::init();

    let terminal = Terminal::new(&document);

    let hidden_input = document
        .get_element_by_id("hidden-input")
        .expect("hidden input not found")
        .dyn_into::<HtmlInputElement>()
        .expect("element is not an input");

    InputSetup::setup(&terminal, &hidden_input);

    wasm_bindgen_futures::spawn_local(async move {
        terminal.init_boot().await;
    });
}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

#[wasm_bindgen]
pub fn greet() {
    log("Terminal loaded");
}
</file>

<file path="src/terminal/renderer.rs">
use super::line_buffer::{self, BufferLine, InputMode, LineType, TerminalState};
use js_sys::Promise;
use std::cell::Cell;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;
use web_sys::{window, CanvasRenderingContext2d, HtmlCanvasElement};

#[derive(Default)]
pub struct LineOptions {
    pub color: Option<String>,
    pub boot_animation: bool,
    pub typing_speed: Option<i32>,
}

impl LineOptions {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_color(mut self, color: &str) -> Self {
        self.color = Some(color.to_string());
        self
    }

    pub fn with_boot_animation(mut self) -> Self {
        self.boot_animation = true;
        self
    }

    pub fn with_typing(mut self, speed: i32) -> Self {
        self.typing_speed = Some(speed);
        self
    }
}

pub struct TerminalRenderer {
    pub canvas: HtmlCanvasElement,
    pub context: CanvasRenderingContext2d,
    pub y: Cell<f64>,
    pub width: i32,
    pub height: i32,
    pub line_height: f64,
    pub char_width: f64,
    pub font_size: i32,
    pub cursor_blink_state: Cell<bool>,
}

impl TerminalRenderer {
    pub fn new(canvas: HtmlCanvasElement, context: CanvasRenderingContext2d) -> Self {
        let width = canvas.width() as i32;
        let height = canvas.height() as i32;
        let font_size = 14;
        let line_height = font_size as f64 + 6.0; // Add some line spacing
        let char_width = font_size as f64 * 0.6; // Monospace character width approximation

        // Configure context
        context.set_font(&format!("{}px 'Courier New', monospace", font_size));
        context.set_text_baseline("top");
        context.set_image_smoothing_enabled(false);

        Self {
            canvas,
            context,
            y: Cell::new(20.0),
            width,
            height,
            line_height,
            char_width,
            font_size,
            cursor_blink_state: Cell::new(true),
        }
    }

    /// Legacy add_line method for compatibility
    pub async fn add_line(&self, text: &str, options: Option<LineOptions>) {
        let opts = options.unwrap_or_default();

        if opts.boot_animation {
            self.boot(text, &opts).await;
        } else if let Some(speed) = opts.typing_speed {
            self.typing(text, speed, &opts).await;
        } else {
            self.simple(text, &opts).await;
        }
    }

    async fn boot(&self, task: &str, opts: &LineOptions) {
        // Disable input during boot animation to prevent prompt from showing
        line_buffer::set_input_mode(InputMode::Disabled);

        let current_y = self.y.get();

        let spinner = ["â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "];
        for &spin_char in &spinner[0..4] {
            let text = format!("{} {}", task, spin_char);
            self.clear_line_at_y(current_y);
            self.draw_text(&text, 10.0, current_y, opts.color.as_deref());
            self.sleep(60).await;
        }

        let final_text = format!("{} [OK]", task);
        self.clear_line_at_y(current_y);
        self.draw_boot_line(&final_text, current_y, opts.color.as_deref());

        // Add to new line buffer
        line_buffer::add_line(final_text, LineType::Boot, opts.color.clone());

        self.advance_y();
        self.handle_scroll_if_needed();
    }

    async fn typing(&self, text: &str, speed: i32, opts: &LineOptions) {
        // Disable input during typing animation to prevent prompt from showing
        line_buffer::set_input_mode(InputMode::Disabled);

        let current_y = self.y.get();
        let mut displayed = String::new();

        for ch in text.chars() {
            displayed.push(ch);
            self.clear_line_at_y(current_y);
            self.draw_text(&displayed, 10.0, current_y, opts.color.as_deref());
            self.sleep(speed).await;
        }

        // Add to new line buffer
        line_buffer::add_line(text.to_string(), LineType::Typing, opts.color.clone());

        self.advance_y();
        self.handle_scroll_if_needed();
    }

    async fn simple(&self, text: &str, opts: &LineOptions) {
        let current_y = self.y.get();

        // Add to new line buffer
        line_buffer::add_line(text.to_string(), LineType::Normal, opts.color.clone());

        self.draw_text(text, 10.0, current_y, opts.color.as_deref());
        self.advance_y();
        self.handle_scroll_if_needed();
    }

    /// Clear the entire canvas
    pub fn clear_screen(&self) {
        self.context.save();
        self.set_fill_color("#000000");
        self.context
            .fill_rect(0.0, 0.0, self.width as f64, self.height as f64);
        self.context.restore();
        self.y.set(20.0);
    }

    /// Calculate maximum lines that fit on screen
    pub fn max_visible_lines(&self) -> usize {
        ((self.height as f64 - 40.0) / self.line_height) as usize
    }

    /// Calculate maximum characters per line
    pub fn max_chars_per_line(&self) -> usize {
        ((self.width as f64 - 20.0) / self.char_width) as usize
    }

    /// Render the entire terminal state using the new line buffer
    pub fn render(&self) {
        self.clear_screen();

        // Update line buffer dimensions
        line_buffer::set_terminal_dimensions(self.max_chars_per_line(), self.max_visible_lines());

        // Get visible lines
        let visible_lines = line_buffer::get_visible_lines(self.max_visible_lines() - 2); // Reserve space for input
        let state = line_buffer::get_terminal_state();

        // Render lines
        let mut y_offset = 20.0;
        for line in visible_lines {
            y_offset += self.render_line(&line, y_offset);
        }

        // Update y position for legacy compatibility
        self.y.set(y_offset);

        // Only render input line if in normal mode (not during animations)
        if state.input_mode == InputMode::Normal {
            self.render_input_line(&state, y_offset);
        }
    }

    /// Render a single buffer line
    fn render_line(&self, line: &BufferLine, y: f64) -> f64 {
        let color = self.get_color_for_line_type(&line.line_type, line.color.as_deref());

        if line.wrapped_lines.is_empty() {
            self.draw_text(&line.content, 10.0, y, Some(&color));
            self.line_height
        } else {
            let mut current_y = y;
            for wrapped_line in &line.wrapped_lines {
                self.draw_text(wrapped_line, 10.0, current_y, Some(&color));
                current_y += self.line_height;
            }
            self.line_height * line.wrapped_lines.len() as f64
        }
    }

    /// Render the input line with prompt and cursor
    fn render_input_line(&self, state: &TerminalState, y: f64) {
        // Clear the input line area
        self.clear_line_at_y(y);

        // Draw prompt
        let prompt_color = "#00ffff"; // Cyan
        self.draw_text(&state.prompt, 10.0, y, Some(prompt_color));

        // Draw input text
        let prompt_width = state.prompt.len() as f64 * self.char_width;
        let input_x = 10.0 + prompt_width;

        if !state.current_input.is_empty() {
            self.draw_text(&state.current_input, input_x, y, Some("#ffffff"));
        }

        // Draw cursor
        if self.cursor_blink_state.get() {
            let cursor_x = input_x + (state.cursor_position as f64 * self.char_width);
            self.draw_cursor(cursor_x, y);
        }
    }

    /// Legacy draw methods for compatibility
    pub fn draw_text(&self, text: &str, x: f64, y: f64, color: Option<&str>) {
        self.context.save();
        self.context.set_font("14px monospace");
        self.context.set_text_baseline("top");

        if let Some(color) = color {
            self.set_fill_color(&self.get_color_value(color));
        } else {
            self.set_fill_color("#ffffff");
        }

        let _ = self.context.fill_text(text, x, y);
        self.context.restore();
    }

    pub fn draw_boot_line(&self, text: &str, y: f64, color: Option<&str>) {
        self.context.save();

        self.context.set_font("14px monospace");
        self.context.set_text_baseline("top");

        if let Some(color) = color {
            self.set_fill_color(&self.get_color_value(color));
        } else {
            self.set_fill_color("#ffffff");
        }

        if let Some(ok_pos) = text.rfind(" [OK]") {
            let main_text = &text[..ok_pos];
            let ok_text = " [OK]";

            self.context.fill_text(main_text, 10.0, y).unwrap();

            let char_width = 8.4;
            let main_width = main_text.len() as f64 * char_width;

            self.set_fill_color("#00ff00");
            self.context
                .fill_text(ok_text, 10.0 + main_width, y)
                .unwrap();
        } else {
            self.context.fill_text(text, 10.0, y).unwrap();
        }

        self.context.restore();
    }

    fn clear_line_at_y(&self, y: f64) {
        self.context.save();
        self.set_fill_color("#000000");
        self.context
            .fill_rect(0.0, y, self.width as f64, self.line_height);
        self.context.restore();
    }

    /// Draw cursor
    fn draw_cursor(&self, x: f64, y: f64) {
        self.context.save();
        self.set_fill_color("#00ff00"); // Green cursor
        self.context.fill_rect(x, y, 2.0, self.line_height - 2.0);
        self.context.restore();
    }

    /// Set fill color for context
    fn set_fill_color(&self, color: &str) {
        let _ = js_sys::Reflect::set(
            &self.context,
            &JsValue::from_str("fillStyle"),
            &JsValue::from_str(color),
        );
    }

    /// Get color for line type
    fn get_color_for_line_type(&self, line_type: &LineType, custom_color: Option<&str>) -> String {
        if let Some(color) = custom_color {
            return self.get_color_value(color);
        }

        match line_type {
            LineType::Command => "#00ffff".to_string(), // Cyan for commands
            LineType::Output => "#ffffff".to_string(),  // White for output
            LineType::Error => "#ff0000".to_string(),   // Red for errors
            LineType::System => "#ffff00".to_string(),  // Yellow for system
            LineType::Boot => "#00ff00".to_string(),    // Green for boot
            LineType::Typing => "#ffffff".to_string(),  // White for typing
            LineType::Prompt => "#00ffff".to_string(),  // Cyan for prompts
            LineType::Normal => "#ffffff".to_string(),  // White for normal
        }
    }

    pub fn get_color_value(&self, color: &str) -> String {
        match color {
            "red" => "#ff0000".to_string(),
            "green" => "#00ff00".to_string(),
            "blue" => "#0000ff".to_string(),
            "yellow" => "#ffff00".to_string(),
            "cyan" => "#00ffff".to_string(),
            "magenta" => "#ff00ff".to_string(),
            "white" => "#ffffff".to_string(),
            "gray" | "grey" => "#808080".to_string(),
            "boot-line" => "#ffffff".to_string(),
            "typing-line" => "#ffffff".to_string(),
            "command" => "#8be9fd".to_string(),
            "completion" => "#f8f8f2".to_string(),
            "error" => "#ff4444".to_string(),
            "success" => "#44ff44".to_string(),
            "warning" => "#ffaa00".to_string(),
            _ => {
                if color.starts_with('#') || color.starts_with("rgb") {
                    color.to_string()
                } else {
                    "#ffffff".to_string()
                }
            }
        }
    }

    fn advance_y(&self) {
        let new_y = self.y.get() + self.line_height;
        self.y.set(new_y);
    }

    // Add method to handle automatic scrolling
    fn handle_scroll_if_needed(&self) {
        let max_lines = (self.height as f64 / self.line_height) as i32;
        let current_line = ((self.y.get() - 20.0) / self.line_height) as i32;

        if current_line >= max_lines - 3 {
            // Need to scroll - use new render system
            self.render();
        }
    }

    pub fn clear_output(&self) {
        line_buffer::clear_buffer();
        self.clear_screen();
        self.prepare_for_input();
    }

    /// Method to draw the current input line with prompt
    pub fn draw_current_input_line(&self, input: &str) {
        let state = line_buffer::get_terminal_state();
        let current_y = self.y.get();

        // Clear the current line first
        self.clear_line_at_y(current_y);

        // Draw prompt in cyan
        self.draw_text(&state.prompt, 10.0, current_y, Some("#00ffff"));

        // Draw input part
        if !input.is_empty() {
            let prompt_width = state.prompt.chars().count() as f64 * self.char_width;
            self.draw_text(input, 10.0 + prompt_width, current_y, Some("#ffffff"));
        }
    }

    /// Method to draw cursor at current position
    pub fn draw_cursor_legacy(&self, input: &str) {
        let state = line_buffer::get_terminal_state();
        let current_y = self.y.get();
        let prompt_width = state.prompt.chars().count() as f64 * self.char_width;
        let input_width = input.chars().count() as f64 * self.char_width;
        let cursor_x = 10.0 + prompt_width + input_width;

        self.context.save();
        self.set_fill_color("#00ff00"); // green cursor
        self.context.fill_text("â–ˆ", cursor_x, current_y).unwrap();
        self.context.restore();
    }

    /// Method to prepare for input (ensures prompt is visible)
    pub fn prepare_for_input(&self) {
        // Set up terminal state
        let _cwd = "/home/objz"; // This should come from command handler
        let display_path = "~";
        let prompt = format!("objz@objz:{}$ ", display_path);

        line_buffer::set_current_prompt(prompt);
        line_buffer::set_input_mode(InputMode::Normal);
        line_buffer::update_input_state(String::new(), 0);
        line_buffer::auto_scroll_to_bottom();

        // Render the terminal
        self.render();
    }

    /// Method to update input display in real-time
    pub fn update_input_display(&self, input: &str) {
        let cursor_pos = input.len(); // For now, cursor is at end
        line_buffer::update_input_state(input.to_string(), cursor_pos);
        self.render();
    }

    /// Method to finalize input (when Enter is pressed)
    pub fn finalize_input(&self, input: &str) {
        let state = line_buffer::get_terminal_state();

        // Add the command to the buffer
        if !input.trim().is_empty() {
            line_buffer::add_command_line(&state.prompt, input);
        }

        // Set processing mode
        line_buffer::set_input_mode(InputMode::Processing);
        line_buffer::update_input_state(String::new(), 0);
    }

    /// Toggle cursor blink state
    pub fn toggle_cursor(&self) {
        self.cursor_blink_state.set(!self.cursor_blink_state.get());
    }

    /// Force cursor visible
    pub fn show_cursor(&self) {
        self.cursor_blink_state.set(true);
    }

    /// Force cursor hidden
    pub fn hide_cursor(&self) {
        self.cursor_blink_state.set(false);
    }

    pub async fn sleep(&self, ms: i32) {
        let promise = Promise::new(&mut |resolve, _reject| {
            let window = window().unwrap();
            let closure = wasm_bindgen::prelude::Closure::once_into_js(move || {
                resolve.call0(&wasm_bindgen::JsValue::UNDEFINED).unwrap();
            });
            window
                .set_timeout_with_callback_and_timeout_and_arguments_0(
                    closure.as_ref().unchecked_ref(),
                    ms,
                )
                .unwrap();
        });

        let _ = JsFuture::from(promise).await;
    }

    pub fn get_current_prompt(&self) -> String {
        line_buffer::get_terminal_state().prompt
    }
}

impl Clone for TerminalRenderer {
    fn clone(&self) -> Self {
        Self {
            canvas: self.canvas.clone(),
            context: self.context.clone(),
            y: Cell::new(self.y.get()),
            width: self.width,
            height: self.height,
            line_height: self.line_height,
            char_width: self.char_width,
            font_size: self.font_size,
            cursor_blink_state: Cell::new(self.cursor_blink_state.get()),
        }
    }
}
</file>

<file path="src/input/setup.rs">
use crate::commands::CommandHandler;
use crate::terminal::line_buffer::InputMode;
use crate::terminal::{
    autocomplete::{find_common_prefix, AutoComplete, CompletionResult},
    line_buffer, Terminal,
};
use crate::utils::panic;
use std::cell::RefCell;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::spawn_local;
use web_sys::{window, HtmlInputElement, KeyboardEvent};

use super::history::CommandHistory;

thread_local! {
    static CURRENT_INPUT: RefCell<String> = RefCell::new(String::new());
    static IS_FOCUSED: RefCell<bool> = RefCell::new(true);
    static AUTOCOMPLETE: RefCell<AutoComplete> = RefCell::new(AutoComplete::new());
}

pub struct InputSetup;

impl InputSetup {
    pub fn setup(terminal: &Terminal, hidden_input: &HtmlInputElement) {
        let history = CommandHistory::new();
        let processor = terminal.command_handler.clone();

        let terminal_clone = terminal.clone();
        let hidden_input_clone = hidden_input.clone();

        let input_callback = {
            let terminal = terminal_clone.clone();
            let hidden_input = hidden_input_clone.clone();

            Closure::wrap(Box::new(move |_event: web_sys::Event| {
                let current_value = hidden_input.value();
                CURRENT_INPUT.with(|input| {
                    *input.borrow_mut() = current_value.clone();
                });

                let cursor_pos = hidden_input
                    .selection_start()
                    .unwrap_or(Some(0))
                    .unwrap_or(0) as usize;

                line_buffer::update_input_state(current_value, cursor_pos);
                terminal.render();
            }) as Box<dyn FnMut(_)>)
        };

        hidden_input
            .add_event_listener_with_callback("input", input_callback.as_ref().unchecked_ref())
            .unwrap();
        input_callback.forget();

        let keydown_callback = {
            let terminal = terminal_clone.clone();
            let hidden_input = hidden_input_clone.clone();
            let history = RefCell::new(history);
            let processor = RefCell::new(processor);

            Closure::wrap(Box::new(move |event: KeyboardEvent| {
                let current_input = CURRENT_INPUT.with(|input| input.borrow().clone());

                match event.key().as_str() {
                    "Enter" => {
                        event.prevent_default();
                        Self::handle_enter(
                            &current_input,
                            &mut history.borrow_mut(),
                            &mut processor.borrow_mut(),
                            &terminal,
                            &hidden_input,
                        );
                    }
                    "ArrowUp" => {
                        event.prevent_default();
                        if let Some(cmd) = history.borrow_mut().prev() {
                            hidden_input.set_value(cmd);
                            CURRENT_INPUT.with(|input| {
                                *input.borrow_mut() = cmd.clone();
                            });
                            line_buffer::update_input_state(cmd.clone(), cmd.len());
                            terminal.render();
                        }
                    }
                    "ArrowDown" => {
                        event.prevent_default();
                        if let Some(cmd) = history.borrow_mut().next() {
                            hidden_input.set_value(cmd);
                            CURRENT_INPUT.with(|input| {
                                *input.borrow_mut() = cmd.clone();
                            });
                            line_buffer::update_input_state(cmd.clone(), cmd.len());
                        } else {
                            hidden_input.set_value("");
                            CURRENT_INPUT.with(|input| {
                                input.borrow_mut().clear();
                            });
                            line_buffer::update_input_state(String::new(), 0);
                        }
                        terminal.render();
                    }
                    "ArrowLeft" => {
                        event.prevent_default();
                        let current_cursor = hidden_input
                            .selection_start()
                            .unwrap_or(Some(0))
                            .unwrap_or(0) as usize;

                        if current_cursor > 0 {
                            let new_cursor = current_cursor - 1;
                            let _ = hidden_input
                                .set_selection_range(new_cursor as u32, new_cursor as u32);
                            line_buffer::update_input_state(current_input, new_cursor);
                            terminal.render();
                        }
                    }
                    "ArrowRight" => {
                        event.prevent_default();
                        let current_cursor = hidden_input
                            .selection_start()
                            .unwrap_or(Some(0))
                            .unwrap_or(0) as usize;

                        let input_len = current_input.len();
                        if current_cursor < input_len {
                            let new_cursor = current_cursor + 1;
                            let _ = hidden_input
                                .set_selection_range(new_cursor as u32, new_cursor as u32);
                            line_buffer::update_input_state(current_input, new_cursor);
                            terminal.render();
                        }
                    }
                    "Home" => {
                        event.prevent_default();
                        let _ = hidden_input.set_selection_range(0, 0);
                        line_buffer::update_input_state(current_input, 0);
                        terminal.render();
                    }
                    "End" => {
                        event.prevent_default();
                        let input_len = current_input.len();
                        let cursor_pos = input_len as u32;
                        let _ = hidden_input.set_selection_range(cursor_pos, cursor_pos);
                        line_buffer::update_input_state(current_input, input_len);
                        terminal.render();
                    }
                    "Tab" => {
                        event.prevent_default();
                        Self::tab_complete(&terminal, &hidden_input, &current_input);
                    }
                    _ => {}
                }
            }) as Box<dyn FnMut(_)>)
        };

        hidden_input
            .add_event_listener_with_callback("keydown", keydown_callback.as_ref().unchecked_ref())
            .unwrap();
        keydown_callback.forget();

        Self::setup_focus_listeners(&terminal_clone, &hidden_input_clone);
        Self::setup_cursor_blink(&terminal_clone);
        Self::setup_custom_listeners(&terminal_clone);

        terminal.prepare_for_input();
        let _ = hidden_input.focus();
    }

    fn setup_focus_listeners(terminal: &Terminal, hidden_input: &HtmlInputElement) {
        let terminal_clone = terminal.clone();

        let focus_callback = {
            let terminal = terminal_clone.clone();
            Closure::wrap(Box::new(move |_event: web_sys::Event| {
                IS_FOCUSED.with(|focused| {
                    *focused.borrow_mut() = true;
                });
                terminal.renderer.show_cursor();
                terminal.render();
            }) as Box<dyn FnMut(_)>)
        };

        hidden_input
            .add_event_listener_with_callback("focus", focus_callback.as_ref().unchecked_ref())
            .unwrap();
        focus_callback.forget();

        let blur_callback = {
            let terminal = terminal_clone.clone();
            Closure::wrap(Box::new(move |_event: web_sys::Event| {
                IS_FOCUSED.with(|focused| {
                    *focused.borrow_mut() = false;
                });
                terminal.renderer.hide_cursor();
                terminal.render();
            }) as Box<dyn FnMut(_)>)
        };

        hidden_input
            .add_event_listener_with_callback("blur", blur_callback.as_ref().unchecked_ref())
            .unwrap();
        blur_callback.forget();
    }

    fn setup_custom_listeners(terminal: &Terminal) {
        let terminal_clone = terminal.clone();
        let window = window().unwrap();

        let focus_event_callback = {
            let terminal = terminal_clone.clone();
            Closure::wrap(Box::new(move |_event: web_sys::Event| {
                IS_FOCUSED.with(|focused| {
                    *focused.borrow_mut() = true;
                });
                terminal.renderer.show_cursor();
                terminal.render();
            }) as Box<dyn FnMut(_)>)
        };

        window
            .add_event_listener_with_callback(
                "terminalFocus",
                focus_event_callback.as_ref().unchecked_ref(),
            )
            .unwrap();
        focus_event_callback.forget();

        let blur_event_callback = {
            let terminal = terminal_clone.clone();
            Closure::wrap(Box::new(move |_event: web_sys::Event| {
                IS_FOCUSED.with(|focused| {
                    *focused.borrow_mut() = false;
                });
                terminal.renderer.hide_cursor();
                terminal.render();
            }) as Box<dyn FnMut(_)>)
        };

        window
            .add_event_listener_with_callback(
                "terminalBlur",
                blur_event_callback.as_ref().unchecked_ref(),
            )
            .unwrap();
        blur_event_callback.forget();
    }

    fn handle_enter(
        current_input: &str,
        history: &mut CommandHistory,
        processor: &mut CommandHandler,
        terminal: &Terminal,
        hidden_input: &HtmlInputElement,
    ) {
        let trimmed_input = current_input.trim();

        if panic::should_panic(trimmed_input) {
            history.add(trimmed_input.to_string());
            let prompt = terminal.get_current_prompt();
            line_buffer::add_command_line(&prompt, trimmed_input);

            hidden_input.set_value("");
            CURRENT_INPUT.with(|input| input.borrow_mut().clear());
            line_buffer::update_input_state(String::new(), 0);
            line_buffer::set_input_mode(InputMode::Processing);

            let terminal_clone = terminal.clone();
            let hidden_input_clone = hidden_input.clone();
            spawn_local(async move {
                panic::trigger(&terminal_clone).await;
                Self::prepare_input(&terminal_clone, &hidden_input_clone);
            });
            return;
        }

        if !trimmed_input.is_empty() {
            history.add(trimmed_input.to_string());
            let prompt = terminal.get_current_prompt();
            line_buffer::add_command_line(&prompt, trimmed_input);
        }

        hidden_input.set_value("");
        CURRENT_INPUT.with(|input| input.borrow_mut().clear());
        line_buffer::update_input_state(String::new(), 0);
        line_buffer::set_input_mode(InputMode::Processing);

        if !trimmed_input.is_empty() {
            let (result, _directory_changed) = processor.handle(trimmed_input);

            match result.as_str() {
                "CLEAR_SCREEN" => {
                    line_buffer::clear_buffer();
                    Self::prepare_input(terminal, hidden_input);
                }
                "SYSTEM_PANIC" => {
                    let terminal_clone = terminal.clone();
                    let hidden_input_clone = hidden_input.clone();
                    spawn_local(async move {
                        panic::trigger(&terminal_clone).await;
                        Self::prepare_input(&terminal_clone, &hidden_input_clone);
                    });
                }
                _ => {
                    if !result.is_empty() {
                        line_buffer::add_output_lines(&result, None);
                    }
                    Self::prepare_input(terminal, hidden_input);
                }
            }
        } else {
            Self::prepare_input(terminal, hidden_input);
        }
    }

    fn prepare_input(terminal: &Terminal, hidden_input: &HtmlInputElement) {
        let prompt = terminal.get_current_prompt();
        line_buffer::set_current_prompt(prompt);
        line_buffer::set_input_mode(InputMode::Normal);
        line_buffer::auto_scroll_to_bottom();

        terminal.render();
        let _ = hidden_input.focus();
    }

    fn tab_complete(terminal: &Terminal, hidden_input: &HtmlInputElement, current_input: &str) {
        let current_path = {
            use crate::commands::filesystem::CURRENT_PATH;
            CURRENT_PATH.lock().unwrap().clone()
        };

        let trimmed = current_input.trim();
        let parts: Vec<&str> = trimmed.split_whitespace().collect();

        let (command_prefix, completion_target) = if parts.is_empty() {
            ("", current_input)
        } else if parts.len() == 1 && !trimmed.ends_with(' ') {
            ("", current_input)
        } else {
            if parts.len() == 1 {
                (trimmed, "")
            } else {
                let last_space_idx = current_input.rfind(' ').unwrap_or(0);
                let prefix = &current_input[..=last_space_idx];
                let target = &current_input[last_space_idx + 1..];
                (prefix, target)
            }
        };

        let completion_result = AUTOCOMPLETE.with(|autocomplete| {
            autocomplete
                .borrow_mut()
                .complete(current_input, &current_path)
        });

        match completion_result {
            CompletionResult::None => {}
            CompletionResult::Single(completion) => {
                let full_completion = if command_prefix.is_empty() {
                    completion
                } else {
                    format!("{}{}", command_prefix, completion)
                };

                hidden_input.set_value(&full_completion);
                CURRENT_INPUT.with(|input| {
                    *input.borrow_mut() = full_completion.clone();
                });

                let cursor_pos = full_completion.len();
                let _ = hidden_input.set_selection_range(cursor_pos as u32, cursor_pos as u32);

                line_buffer::update_input_state(full_completion, cursor_pos);
                terminal.render();
            }
            CompletionResult::Multiple(completions) => {
                if let Some(common_prefix) = find_common_prefix(&completions) {
                    if common_prefix.len() > completion_target.len() {
                        let full_completion = if command_prefix.is_empty() {
                            common_prefix
                        } else {
                            format!("{}{}", command_prefix, common_prefix)
                        };

                        hidden_input.set_value(&full_completion);
                        CURRENT_INPUT.with(|input| {
                            *input.borrow_mut() = full_completion.clone();
                        });

                        let cursor_pos = full_completion.len();
                        let _ =
                            hidden_input.set_selection_range(cursor_pos as u32, cursor_pos as u32);

                        line_buffer::update_input_state(full_completion, cursor_pos);
                        terminal.render();
                        return;
                    }
                }

                let prompt = terminal.get_current_prompt();
                line_buffer::add_command_line(&prompt, current_input);

                let completions_text = if completions.len() <= 10 {
                    completions.join("  ")
                } else {
                    let mut output = String::new();
                    for (i, completion) in completions.iter().enumerate() {
                        if i > 0 && i % 4 == 0 {
                            output.push('\n');
                        } else if i > 0 {
                            output.push_str("  ");
                        }
                        output.push_str(completion);
                    }
                    output
                };

                line_buffer::add_output_lines(&completions_text, None);

                Self::prepare_input(terminal, hidden_input);
                hidden_input.set_value(current_input);
                CURRENT_INPUT.with(|input| {
                    *input.borrow_mut() = current_input.to_string();
                });

                let cursor_pos = current_input.len();
                let _ = hidden_input.set_selection_range(cursor_pos as u32, cursor_pos as u32);

                line_buffer::update_input_state(current_input.to_string(), cursor_pos);
                terminal.render();
            }
        }
    }

    fn setup_cursor_blink(terminal: &Terminal) {
        let terminal_clone = terminal.clone();

        let blink_callback = Closure::wrap(Box::new(move || {
            let is_focused = IS_FOCUSED.with(|focused| *focused.borrow());
            let state = line_buffer::get_terminal_state();

            if is_focused && state.input_mode == InputMode::Normal {
                terminal_clone.renderer.toggle_cursor();
                terminal_clone.render();
            }
        }) as Box<dyn FnMut()>);

        window()
            .unwrap()
            .set_interval_with_callback_and_timeout_and_arguments_0(
                blink_callback.as_ref().unchecked_ref(),
                500,
            )
            .unwrap();
        blink_callback.forget();
    }
}
</file>

<file path="style/styles.css">
/* Reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
  color: #e6e6e6;
  font-family:
    "JetBrains Mono", "Fira Code", "Source Code Pro", "Consolas", monospace;
  overflow: hidden;
}

/* 3D Scene Styles */
#scene-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 10;
}

/* Loading Screen */
#loading {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  color: #8be9fd;
  font-family: "JetBrains Mono", monospace;
  transition: opacity 0.5s ease;
}

#loading.hidden {
  opacity: 0;
  pointer-events: none;
}

.loading-text {
  font-size: 18px;
  text-shadow: 0 0 10px rgba(139, 233, 253, 0.5);
}

.loading-bar {
  background: #333;
  border-radius: 2px;
  overflow: hidden;
  width: 300px;
  height: 4px;
  margin-top: 20px;
}

.loading-progress {
  background: linear-gradient(90deg, #8be9fd, #50fa7b);
  transition: width 0.3s ease;
  box-shadow: 0 0 10px rgba(139, 233, 253, 0.3);
  height: 100%;
  width: 0%;
}

/* Terminal Canvas Styles */
#terminal {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  /* width: 800px; */
  /* height: 600px; */
  z-index: 20;
  visibility: visible;
  background: #000000;

  /* Debug red outline */
  border: 3px solid #ff0000;
  box-shadow:
    0 0 10px rgba(255, 0, 0, 0.5),
    0 0 20px rgba(139, 233, 253, 0.3);

  /* Canvas specific styles */
  display: block;
  border-radius: 4px;

  /* Make it focusable */
  outline: none;

  /* Ensure crisp pixel rendering */
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

/* When terminal is focused */
#terminal:focus {
  border-color: #ff0000;
  box-shadow:
    0 0 15px rgba(255, 0, 0, 0.8),
    0 0 30px rgba(139, 233, 253, 0.5);
}

/* Terminal in texture mode (when being used as 3D texture) */
#terminal.texture-mode {
  visibility: hidden;
  position: fixed;
  top: -9999px;
  left: -9999px;
  z-index: -1;
}

/* Debug info overlay */
.debug-info {
  position: fixed;
  top: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: #00ff00;
  padding: 10px;
  font-family: monospace;
  font-size: 12px;
  border: 1px solid #00ff00;
  z-index: 1000;
  border-radius: 4px;
}

/* Media queries for responsive design */
@media (max-width: 1024px) {
  #terminal {
    width: 90vw;
    height: 70vh;
    max-width: 800px;
    max-height: 600px;
  }
}

@media (max-width: 768px) {
  #terminal {
    width: 95vw;
    height: 75vh;
    font-size: 14px;
  }
}
</file>

<file path="README.md">
Hi ![](https://user-images.githubusercontent.com/18350557/176309783-0785949b-9127-417c-8b55-ab5a4333674e.gif) My name is Consti
==============================================================================================================================

* I'm based in Bavaria - Germany
* I'm currently working on [CommandBridge](https://github.com/72-S/CommandBridge) and [mcl](https://github.com/72-S/mcl)

### Skills
[![My Skills](https://skillicons.dev/icons?i=c,cpp,rust,java,linux,arch,neovim)](https://skillicons.dev)


<img src="https://raw.githubusercontent.com/72-S/72-S/output/snake.svg" alt="Snake animation" />
</file>

</files>
