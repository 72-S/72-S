This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
    snake.yml
js/
  index.js
  model.js
src/
  ascii_art/
    mod.rs
    user.rs
  boot/
    boot.rs
    mod.rs
  commands/
    filesystem.rs
    misc.rs
    mod.rs
    processor.rs
    system.rs
  input/
    autoscroll.rs
    history.rs
    mod.rs
    setup.rs
  terminal/
    autocomplete.rs
    core.rs
    mod.rs
    renderer.rs
  utils/
    mod.rs
    panic.rs
  lib.rs
static/
  index.html
style/
  styles.css
.gitignore
build.sh
Cargo.toml
README.md
serve.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/input/history.rs">
use std::collections::VecDeque;

#[derive(Clone)]
pub struct CommandHistory {
    commands: VecDeque<String>,
    current_index: Option<usize>,
    max_size: usize,
}

impl CommandHistory {
    pub fn new(max_size: usize) -> Self {
        Self {
            commands: VecDeque::new(),
            current_index: None,
            max_size,
        }
    }

    pub fn add(&mut self, cmd: String) {
        let trimmed = cmd.trim();
        if !trimmed.is_empty() {
            if let Some(pos) = self.commands.iter().position(|x| x == trimmed) {
                self.commands.remove(pos);
            }
            self.commands.push_front(trimmed.to_string());
            if self.commands.len() > self.max_size {
                self.commands.pop_back();
            }
        }
        self.current_index = None;
    }

    pub fn previous(&mut self) -> Option<String> {
        if self.commands.is_empty() {
            return None;
        }
        match self.current_index {
            None => {
                self.current_index = Some(0);
                self.commands.get(0).cloned()
            }
            Some(idx) if idx + 1 < self.commands.len() => {
                self.current_index = Some(idx + 1);
                self.commands.get(idx + 1).cloned()
            }
            Some(idx) => self.commands.get(idx).cloned(),
        }
    }

    pub fn next(&mut self) -> Option<String> {
        match self.current_index {
            None => None,
            Some(0) => {
                self.current_index = None;
                Some(String::new())
            }
            Some(idx) => {
                let new_idx = idx - 1;
                self.current_index = Some(new_idx);
                self.commands.get(new_idx).cloned()
            }
        }
    }
}
</file>

<file path="src/input/mod.rs">
pub mod autoscroll;
pub mod history;
pub mod setup;
</file>

<file path="src/ascii_art/mod.rs">
pub mod user;

use user::user;

#[derive(Clone)]
pub struct AsciiArt;

impl AsciiArt {
    pub fn get_user() -> String {
        user()
    }
}
</file>

<file path="src/ascii_art/user.rs">
pub fn user() -> String {
    r#"
   ___  ___    _ ____
  / _ \| _ )_ | |_  /
 | (_) | _ \ || |/ / 
  \___/|___/\__//___|

  [ me@objz.dev ]

  "Code is poetry in motion"
    "#
    .to_string()
}
</file>

<file path="src/commands/mod.rs">
pub mod filesystem;
pub mod misc;
pub mod processor;
pub mod system;

pub use processor::CommandHandler;
</file>

<file path="src/commands/system.rs">
use crate::ascii_art::AsciiArt;
use std::sync::OnceLock;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = Date)]
    fn now() -> f64;

    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

static START_TIME: OnceLock<f64> = OnceLock::new();
pub fn init() {
    START_TIME.set(now()).ok();
}

pub fn clear(_args: &[&str]) -> String {
    "CLEAR_SCREEN".to_string()
}

pub fn echo(args: &[&str]) -> String {
    if args.is_empty() {
        String::new()
    } else if args[0] == "$USER" {
        AsciiArt::get_user()
    } else {
        args.join(" ")
    }
}

pub fn date(_args: &[&str]) -> String {
    let millis = now();
    let date = js_sys::Date::new(&JsValue::from_f64(millis));
    date.to_iso_string().into()
}

pub fn uptime(_args: &[&str]) -> String {
    let start = *START_TIME.get().unwrap_or(&now());
    let elapsed = now() - start;

    let total_secs = (elapsed / 1000.0) as u64;
    let hours = total_secs / 3600;
    let minutes = (total_secs % 3600) / 60;
    let seconds = total_secs % 60;

    format!("{:02}h {:02}m {:02}s", hours, minutes, seconds)
}

pub fn neofetch(_args: &[&str]) -> String {
    r#"                   -`                    objz@portfolio
                  .o+`                   -----------------
                 `ooo/                   OS: Portfolio Linux x86_64
                `+oooo:                  Host: GitHub Pages
               `+oooooo:                 Kernel: WASM 6.6.6
               -+oooooo+:                Uptime: 17 days, 13 hours, 28 mins
             `/:-:++oooo+:               Packages: 42 (rust), 13 (npm)
            `/++++/+++++++:              Shell: objz-shell 3.0.0
           `/++++++++++++++:             Resolution: 1920x1080
          `/+++ooooooooo++++/            WM: Terminal Emulator
         ./ooosssso++osssssso+`          Theme: Dark
        .oossssso-````/ossssss+`         Icons: ASCII Art Pack
       -osssssso.      :ssssssso.        Terminal: objz-term
      :osssssss/        +sssso+++.
     /ossssssss/        +ssssooo/-       Memory: 521MiB / ‚àûGiB
   `/ossssso+/:-        -:/+osssso+-     
  `+sso+:-`                 `.-/+oso:    
 `++:.                           `-/+/   
 .`                                 `/   "#
        .to_string()
}
</file>

<file path=".github/workflows/snake.yml">
name: Generate snake animation

on:
  schedule: # execute every 12 hours
    - cron: "* */12 * * *"

  workflow_dispatch:

  push:
    branches:
    - main

jobs:
  generate:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: generate snake.svg
        uses: Platane/snk/svg-only@v3
        with:
          github_user_name: ${{ github.repository_owner }}
          outputs: dist/snake.svg?palette=github-dark


      - name: push snake.svg to the output branch
        uses: crazy-max/ghaction-github-pages@v3.1.0
        with:
          target_branch: output
          build_dir: dist
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path="js/index.js">
import init from "../pkg/portfolio.js";
import { Terminal3D } from "./model.js";

init().then(() => {
  console.log("Portfolio loaded successfully!");
});

document.addEventListener("DOMContentLoaded", () => {
  setTimeout(() => {
    window.terminal3d = new Terminal3D();
  }, 1000);
});

window.addEventListener("beforeunload", () => {
  if (window.terminal3d) {
    window.terminal3d.dispose();
  }
});
</file>

<file path="src/boot/boot.rs">
use crate::terminal::{renderer::LineOptions, Terminal};

pub async fn boot(term: &Terminal) {
    let boot_messages = vec![
        (
            "Loading Linux kernel version 6.8.9-arch1-1...",
            "[OK]",
            "green",
        ),
        ("Loading initial ramdisk (initramfs)...", "[OK]", "green"),
        ("Starting systemd-udevd v254.5-1...", "[OK]", "green"),
        ("Probing hardware...", "[OK]", "green"),
        ("Detected storage device: /dev/nvme0n1", "[OK]", "green"),
        ("Detected storage device: /dev/sda", "[OK]", "green"),
        ("Started udev Kernel Device Manager.", "[OK]", "green"),
        ("Activating swap on /dev/sda2...", "[OK]", "green"),
        ("Mounting root filesystem...", "[OK]", "green"),
        ("Checking file system on /dev/sda1...", "[OK]", "green"),
        ("Mounting /boot...", "[OK]", "green"),
        ("Mounting /home...", "[OK]", "green"),
        ("Mounting /var...", "[OK]", "green"),
        ("Starting systemd-journald.service...", "[OK]", "green"),
        (
            "Starting systemd-tmpfiles-setup-dev.service...",
            "[OK]",
            "green",
        ),
        ("Starting systemd-sysctl.service...", "[OK]", "green"),
        ("Starting Load Kernel Modules...", "[OK]", "green"),
        ("Loading kernel modules: i915 ext4 fuse...", "[OK]", "green"),
        (
            "Started Rule-based Manager for Device Events and Filesystems.",
            "[OK]",
            "green",
        ),
        ("Starting Network Manager...", "[OK]", "green"),
        ("Started Network Time Synchronization.", "[OK]", "green"),
        (
            "Starting Login Service (systemd-logind)...",
            "[OK]",
            "green",
        ),
        (
            "Starting Authorization Manager (polkitd)...",
            "[OK]",
            "green",
        ),
        ("Starting User Manager for UID 1000...", "[OK]", "green"),
        ("Started Getty on tty1.", "[OK]", "green"),
        ("Reached target Multi-User System.", "[OK]", "green"),
        ("Starting Interface...", "[OK]", "green"),
    ];

    for (msg, _status, color) in boot_messages {
        term.add_line(
            msg,
            Some(LineOptions::new().with_boot_animation().with_color(color)),
        )
        .await;
        term.sleep(15).await;
    }
    term.add_line("", None).await;
    term.add_line(
        "Started objz Terminal",
        Some(LineOptions::new().with_boot_animation().with_color("green")),
    )
    .await;
    term.sleep(200).await;
    term.add_line("", None).await;
}

pub async fn logo(term: &Terminal) {
    let logo_lines = vec![
        "                                                    ",
        " ‚ñë‚ñí‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë       ‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñí‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë ",
        "‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë      ‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë      ‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë",
        "‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë      ‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë    ‚ñë‚ñí‚ñì‚ñà‚ñà‚ñì‚ñí‚ñë ",
        "‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñí‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë       ‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë  ‚ñë‚ñí‚ñì‚ñà‚ñà‚ñì‚ñí‚ñë   ",
        "‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñà‚ñì‚ñí‚ñë     ",
        "‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë       ",
        " ‚ñë‚ñí‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë ‚ñë‚ñí‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñí‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë",
        "                                                    ",
    ];

    for line in logo_lines {
        term.add_line(
            line,
            Some(LineOptions::new().with_typing(10).with_color("cyan")),
        )
        .await;
        term.sleep(30).await;
    }
}

pub async fn login(term: &Terminal) {
    let login_messages = vec![
        ("Arch Linux 6.6.32-1-lts (tty1)", "", "green"),
        ("", "", ""),
        ("login: anonym", "", "white"),
        ("password: ", "", "white"),
        ("", "", ""),
        ("Last login: Mon May 27 13:59:36 2025", "", "white"),
        ("Type 'help' for further information", "", "yellow"),
        ("", "", ""),
    ];

    for (msg, _status, color) in login_messages {
        if msg.is_empty() {
            term.add_line("", None).await;
        } else if msg.contains("login:") {
            term.add_line(msg, Some(LineOptions::new().with_typing(50)))
                .await;
        } else if msg.contains("password:") {
            let full = format!("{}‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢", msg);
            term.add_line(&full, Some(LineOptions::new().with_typing(50)))
                .await;
        } else {
            term.add_line(msg, Some(LineOptions::new().with_color(color)))
                .await;
        }
        term.sleep(60).await;
    }
}
</file>

<file path="src/boot/mod.rs">
use crate::terminal::Terminal;

pub mod boot;

impl Terminal {
    pub async fn init_boot(&self) {
        self.clear_output();
        boot::boot(self).await;
        boot::logo(self).await;
        boot::login(self).await;
    }
}
</file>

<file path="src/input/autoscroll.rs">
use wasm_bindgen::prelude::*;
use web_sys::window;

pub fn ensure_autoscroll() {
    if let Some(window) = window() {
        if let Some(doc) = window.document() {
            if let Some(body) = doc.get_element_by_id("terminal-body") {
                body.set_scroll_top(body.scroll_height());

                let _ =
                    js_sys::eval("if (window.objzEnsureAutoscroll) window.objzEnsureAutoscroll();");

                let body_clone = body.clone();
                let closure = Closure::once_into_js(Box::new(move || {
                    body_clone.set_scroll_top(body_clone.scroll_height());
                }) as Box<dyn FnOnce()>);

                let _ = window.set_timeout_with_callback_and_timeout_and_arguments_0(
                    closure.as_ref().unchecked_ref(),
                    0,
                );
            }
        }
    }
}

pub fn trim_output(max_height: i32) {
    if let Some(doc) = window().unwrap().document() {
        if let Some(output) = doc.get_element_by_id("terminal-output") {
            let output_el: web_sys::HtmlElement = output.unchecked_into();
            while output_el.scroll_height() > max_height && output_el.child_element_count() > 1 {
                let first = output_el.first_element_child();
                if let Some(f) = first {
                    let _ = output_el.remove_child(&f);
                }
            }
        }
    }
}
</file>

<file path="src/terminal/autocomplete.rs">
pub struct AutoComplete {
    commands: Vec<String>,
}

impl AutoComplete {
    pub fn new() -> Self {
        let commands = vec![
            "help", "clear", "history", "echo", "date", "uptime", "neofetch", "uname", "ls", "ll",
            "cd", "cat", "pwd", "tree", "mkdir", "touch", "rm", "ln", "sudo", "cowsay", "sl",
            "lolcat", "calc",
        ]
        .into_iter()
        .map(|s| s.to_string())
        .collect();

        Self { commands }
    }

    pub fn complete(&mut self, input: &str, current_path: &[String]) -> CompletionResult {
        let trimmed = input.trim();
        if trimmed.is_empty() {
            return CompletionResult::None;
        }

        let parts: Vec<&str> = trimmed.split_whitespace().collect();

        if parts.len() == 1 {
            self.complete_command(&parts[0])
        } else {
            let command = parts[0];
            let partial_path = parts.last().map_or("", |v| v);

            match command {
                "cd" | "ls" | "cat" | "tree" | "rm" | "mkdir" | "touch" => {
                    self.complete_path(partial_path, current_path, command == "cd")
                }
                _ => CompletionResult::None,
            }
        }
    }

    fn complete_command(&self, partial: &str) -> CompletionResult {
        let matches: Vec<String> = self
            .commands
            .iter()
            .filter(|cmd| cmd.starts_with(partial))
            .cloned()
            .collect();

        match matches.len() {
            0 => CompletionResult::None,
            1 => CompletionResult::Single(matches[0].clone()),
            _ => CompletionResult::Multiple(matches),
        }
    }

    fn complete_path(
        &mut self,
        partial: &str,
        current_path: &[String],
        dirs_only: bool,
    ) -> CompletionResult {
        use crate::commands::filesystem::{get_filesystem_entries, normalize_path};

        let (dir_path, filename_prefix) = if partial.contains('/') {
            let last_slash = partial.rfind('/').unwrap();
            (&partial[..last_slash + 1], &partial[last_slash + 1..])
        } else {
            ("", partial)
        };

        let search_path = if dir_path.is_empty() {
            current_path.to_vec()
        } else {
            normalize_path(dir_path, current_path)
        };

        let entries = get_filesystem_entries(&search_path, dirs_only);

        let matches: Vec<String> = entries
            .into_iter()
            .filter(|entry| entry.starts_with(filename_prefix))
            .map(|entry| {
                if dir_path.is_empty() {
                    entry
                } else {
                    format!("{}{}", dir_path, entry)
                }
            })
            .collect();

        match matches.len() {
            0 => CompletionResult::None,
            1 => CompletionResult::Single(matches[0].clone()),
            _ => CompletionResult::Multiple(matches),
        }
    }
}

#[derive(Debug)]
pub enum CompletionResult {
    None,
    Single(String),
    Multiple(Vec<String>),
}

pub fn find_common_prefix(strings: &[String]) -> Option<String> {
    if strings.is_empty() {
        return None;
    }

    let first = &strings[0];
    let mut prefix = String::new();

    for (i, ch) in first.chars().enumerate() {
        if strings.iter().all(|s| s.chars().nth(i) == Some(ch)) {
            prefix.push(ch);
        } else {
            break;
        }
    }

    if prefix.is_empty() {
        None
    } else {
        Some(prefix)
    }
}
</file>

<file path="src/terminal/mod.rs">
pub mod autocomplete;
pub mod core;
pub mod renderer;

pub use core::Terminal;
</file>

<file path="src/utils/mod.rs">
pub mod panic;
</file>

<file path="src/utils/panic.rs">
use crate::terminal::{renderer::LineOptions, Terminal};

pub async fn system_panic(terminal: &Terminal) {
    terminal.clear_output();

    let panic_lines = vec![
        ("‚ö†Ô∏è  CRITICAL SYSTEM ERROR ‚ö†Ô∏è", Some("error"), None),
        ("", None, None),
        ("Deleting root filesystem...", Some("warning"), Some(100)),
        (
            "rm: removing /usr... ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë 75%",
            Some("warning"),
            Some(80),
        ),
        (
            "rm: removing /var... ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë 87%",
            Some("warning"),
            Some(80),
        ),
        (
            "rm: removing /etc... ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 100%",
            Some("warning"),
            Some(80),
        ),
        ("", None, None),
        ("SYSTEM DESTROYED ‚ò†Ô∏è", Some("error"), Some(150)),
        ("", None, None),
        (
            "Just kidding! This is a just website, not your actual system.",
            Some("success"),
            Some(50),
        ),
        ("Nice try though! üòâ", Some("success"), None),
        ("", None, None),
        (
            "(Don't actually run 'sudo rm -rf /' on real systems!)",
            Some("warning"),
            None,
        ),
        ("", None, None),
    ];

    for (line, color, typing_speed) in panic_lines {
        let mut options = LineOptions::new();

        if let Some(color_class) = color {
            options = options.with_color(color_class);
        }

        if let Some(speed) = typing_speed {
            options = options.with_typing(speed);
        }

        terminal.add_line(line, Some(options)).await;

        terminal.sleep(300).await;
    }

    terminal.sleep(2000).await;

    terminal.clear_output();

    terminal
        .add_line(
            "System restored! Terminal is back online.",
            Some(LineOptions::new().with_color("success")),
        )
        .await;

    terminal.add_line("", None).await;
}
</file>

<file path="build.sh">
#!/bin/zsh
wasm-pack build --target web --out-dir pkg
rm -rf dist 
mkdir -p dist/js
mkdir -p dist/style
cp -r static/* dist/
cp -r style/* dist/style/
cp -r js/* dist/js/
cp -r pkg dist/
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Install wasm-pack
        run: |
          curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      - name: Build WASM
        run: |
          wasm-pack build --target web --out-dir pkg

      - name: Prepare static site
        run: |
          mkdir -p dist/js
          mkdir -p dist/style
          cp -r static/* dist/
          cp -r style/* dist/style/
          cp -r js/* dist/js/
          cp -r pkg dist/

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist
</file>

<file path="src/terminal/core.rs">
use std::cell::Cell;

use crate::commands::CommandHandler;
use js_sys::Promise;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;
use web_sys::{window, CanvasRenderingContext2d, Document, HtmlCanvasElement};

#[derive(Clone)]
pub struct Terminal {
    pub canvas: HtmlCanvasElement,
    pub context: CanvasRenderingContext2d,
    pub y: Cell<f64>,
    pub line_height: f64,
    pub command_handler: CommandHandler,
    pub base_prompt: String,
    pub height: i32,
    pub width: i32,
}

impl Terminal {
    pub fn new(document: &Document) -> Self {
        let canvas = document
            .get_element_by_id("terminal")
            .expect("canvas not found")
            .dyn_into::<HtmlCanvasElement>()
            .expect("element is not a canvas");

        let context = canvas
            .get_context("2d")
            .expect("failed to get 2d context")
            .unwrap()
            .dyn_into::<CanvasRenderingContext2d>()
            .expect("failed to cast to CanvasRenderingContext2d");

        let command_handler = CommandHandler::new();
        let base_prompt = "anonym@objz".to_string();
        let height = 800;
        let width = 600;

        Self {
            canvas,
            context,
            y: Cell::new(20.0),
            line_height: 20.0,
            command_handler,
            base_prompt,
            height,
            width,
        }
    }

    pub fn get_current_prompt(&self) -> String {
        let cwd = self.command_handler.get_current_directory();
        let display_path = if cwd == "/home/objz" {
            "~".to_string()
        } else if cwd.starts_with("/home/objz/") {
            format!("~{}", &cwd["/home/objz".len()..])
        } else {
            cwd
        };

        format!("{}:{}$ ", self.base_prompt, display_path)
    }

    pub async fn sleep(&self, ms: i32) {
        let promise = Promise::new(&mut |resolve, _reject| {
            let window = window().unwrap();
            let closure = Closure::once_into_js(move || {
                resolve.call0(&JsValue::UNDEFINED).unwrap();
            });
            window
                .set_timeout_with_callback_and_timeout_and_arguments_0(
                    closure.as_ref().unchecked_ref(),
                    ms,
                )
                .unwrap();
        });

        let _ = JsFuture::from(promise).await;
    }
}
</file>

<file path=".gitignore">
/target
**/*.rs.bk
Cargo.lock
bin/
pkg/
dist/
target/
wasm-pack.log
# repomix-output.xml
</file>

<file path="serve.sh">
#!/bin/zsh
./build.sh
npx serve dist
</file>

<file path="js/model.js">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

export class Terminal3D {
  constructor() {
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.controls = null;
    this.pcModel = null;
    this.screenMesh = null;
    this.terminalTexture = null;
    this.terminalCanvas = null; // Add reference to terminal canvas
    this.isTerminalFocused = false;
    this.animationId = null;
    this.init();
  }

  async init() {
    try {
      this.updateLoadingProgress(10);
      await this.setupScene();
      this.updateLoadingProgress(30);
      await this.loadPCModel();
      this.updateLoadingProgress(60);
      await this.setupTerminalTexture();
      this.updateLoadingProgress(80);
      this.setupEventListeners();
      this.updateLoadingProgress(100);
      this.hideLoading();
      this.showTerminal();
      this.animate();
    } catch (e) {
      console.error("3D init failed:", e);
      this.showError();
    }
  }

  updateLoadingProgress(p) {
    const bar = document.getElementById("loading-progress");
    if (bar) bar.style.width = p + "%";
  }

  hideLoading() {
    setTimeout(() => {
      const L = document.getElementById("loading");
      if (L) L.classList.add("hidden");
    }, 500);
  }

  showError() {
    const txt = document.querySelector(".loading-text");
    if (txt) {
      txt.textContent = "Failed to load 3D. Showing terminal.";
      txt.style.color = "#ff5555";
    }
    setTimeout(() => {
      const L = document.getElementById("loading");
      if (L) L.classList.add("hidden");
      const term = document.getElementById("terminal");
      if (term) term.style.visibility = "visible";
    }, 2000);
  }

  showTerminal() {
    const terminal = document.getElementById("terminal");
    if (terminal) {
      terminal.style.visibility = "visible";
    }
  }

  async setupScene() {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x0a0a0a);
    this.camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      100,
    );
    this.camera.position.set(0, 1.5, 3);
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    document
      .getElementById("scene-container")
      .appendChild(this.renderer.domElement);
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.target.set(0, 1, 0);

    this.scene.add(new THREE.HemisphereLight(0x8be9fd, 0x444444, 0.3));
  }

  async loadPCModel() {
    console.log("Loading PC model...");
    return new Promise((resolve) => {
      const loader = new GLTFLoader();
      loader.load(
        "./pc.glb",
        (gltf) => {
          console.log("Model loaded");
          this.pcModel = gltf.scene;
          this.pcModel.scale.setScalar(1);
          this.pcModel.position.set(0, 0, 0);

          this.pcModel.traverse((c) => {
            if (c.isMesh) {
              c.castShadow = c.receiveShadow = true;
              const n = c.name.toLowerCase();
              const m = c.material?.name?.toLowerCase() || "";
              if (
                n.includes("screen") ||
                n.includes("monitor") ||
                m.includes("screen") ||
                m.includes("monitor") ||
                c.name === "Plane008_Material002_0"
              ) {
                this.screenMesh = c;
                console.log("Found screen:", c.name);
              }
            }
          });
          if (!this.screenMesh) {
            this.findScreenMesh();
          }
          this.scene.add(this.pcModel);
          resolve();
        },
        (prog) => {
          const pct = 30 + (prog.loaded / prog.total) * 30;
          this.updateLoadingProgress(pct);
        },
        (err) => {
          console.warn("Model load failed:", err);
          resolve();
        },
      );
    });
  }

  findScreenMesh() {
    const candidates = [];
    this.pcModel.traverse((c) => {
      if (c.isMesh && c.geometry) {
        const box = new THREE.Box3().setFromObject(c);
        const s = box.getSize(new THREE.Vector3());
        const flat = Math.min(s.x, s.y, s.z) < Math.max(s.x, s.y, s.z) * 0.1;
        const big = Math.max(s.x, s.y, s.z) > 0.5;
        if (flat && big) candidates.push({ mesh: c, area: s.x * s.y * s.z });
      }
    });
    if (candidates.length) {
      candidates.sort((a, b) => b.area - a.area);
      this.screenMesh = candidates[0].mesh;
    } else {
      this.pcModel.traverse((c) => {
        if (!this.screenMesh && c.isMesh) this.screenMesh = c;
      });
    }
  }

  async setupTerminalTexture() {
    // Get the terminal canvas directly (created by your Rust code)
    this.terminalCanvas = document.getElementById("terminal");

    if (!this.terminalCanvas) {
      console.error("Terminal canvas not found!");
      return;
    }

    // Wait a frame to ensure canvas is ready
    await new Promise((r) => requestAnimationFrame(r));

    // Create Three.js texture from the existing canvas
    this.terminalTexture = new THREE.CanvasTexture(this.terminalCanvas);
    this.terminalTexture.minFilter = THREE.LinearFilter;
    this.terminalTexture.magFilter = THREE.LinearFilter;
    this.terminalTexture.flipY = false; // Canvas is already correct orientation

    // Apply texture to screen mesh
    if (this.screenMesh) {
      this.screenMesh.material = new THREE.MeshBasicMaterial({
        map: this.terminalTexture,
        emissive: new THREE.Color(0x001a1a),
        emissiveIntensity: 0.1,
      });
    }

    // Adjust texture mapping if needed
    this.terminalTexture.offset.y = 0.0;
    this.terminalTexture.repeat.y = 1.0;

    // Set up automatic texture updates
    this.updateTerminalTexture = () => {
      try {
        // The canvas is automatically updated by your Rust terminal renderer
        // We just need to tell Three.js to update the texture
        if (this.terminalTexture) {
          this.terminalTexture.needsUpdate = true;
        }
      } catch (e) {
        console.warn("Texture update failed:", e);
      }
    };

    // Update texture regularly to sync with terminal changes
    setInterval(() => {
      this.updateTerminalTexture();
    }, 16); // ~60fps updates
  }

  setupEventListeners() {
    window.addEventListener("resize", () => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Set up raycasting for screen clicks
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();

    this.renderer.domElement.addEventListener("click", (event) => {
      this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      this.raycaster.setFromCamera(this.mouse, this.camera);

      const intersectables = [];
      if (this.pcModel) {
        this.pcModel.traverse((child) => {
          if (child.isMesh) {
            intersectables.push(child);
          }
        });
      }
      if (this.screenMesh && !intersectables.includes(this.screenMesh)) {
        intersectables.push(this.screenMesh);
      }

      const intersects = this.raycaster.intersectObjects(intersectables);

      if (intersects.length > 0) {
        const clickedObject = intersects[0].object;
        console.log(
          "Clicked object:",
          clickedObject.name || "unnamed",
          clickedObject,
        );

        const isScreen =
          clickedObject.name === "Plane008_Material002_0" ||
          clickedObject === this.screenMesh ||
          clickedObject.material?.map === this.terminalTexture ||
          (clickedObject.name &&
            clickedObject.name.toLowerCase().includes("screen"));

        if (isScreen) {
          console.log("Screen clicked - focusing terminal");
          this.isTerminalFocused = true;

          // Focus the terminal canvas for keyboard input
          if (this.terminalCanvas) {
            this.terminalCanvas.focus();
          }

          // Trigger any terminal focus events if your Rust code needs them
          const focusEvent = new CustomEvent("terminalFocus");
          window.dispatchEvent(focusEvent);
        } else {
          console.log("Clicked on non-screen object - removing focus");
          this.isTerminalFocused = false;

          if (this.terminalCanvas) {
            this.terminalCanvas.blur();
          }

          const blurEvent = new CustomEvent("terminalBlur");
          window.dispatchEvent(blurEvent);
        }
      } else {
        console.log("Clicked on empty space - removing focus");
        this.isTerminalFocused = false;

        if (this.terminalCanvas) {
          this.terminalCanvas.blur();
        }

        const blurEvent = new CustomEvent("terminalBlur");
        window.dispatchEvent(blurEvent);
      }
    });

    // Handle clicks outside the 3D scene
    document.addEventListener("click", (e) => {
      if (
        !e.target.closest("#scene-container") &&
        !e.target.closest("#terminal")
      ) {
        console.log("Clicked outside - removing focus");
        this.isTerminalFocused = false;

        if (this.terminalCanvas) {
          this.terminalCanvas.blur();
        }

        const blurEvent = new CustomEvent("terminalBlur");
        window.dispatchEvent(blurEvent);
      }
    });

    // Forward keyboard events to terminal when focused
    document.addEventListener("keydown", (e) => {
      if (this.isTerminalFocused && this.terminalCanvas) {
        // Create a new keyboard event and dispatch it to the canvas
        const terminalKeyEvent = new KeyboardEvent("keydown", {
          key: e.key,
          code: e.code,
          ctrlKey: e.ctrlKey,
          shiftKey: e.shiftKey,
          altKey: e.altKey,
          metaKey: e.metaKey,
        });

        this.terminalCanvas.dispatchEvent(terminalKeyEvent);

        // Prevent default if the terminal should handle this key
        if (
          !e.ctrlKey ||
          (e.ctrlKey && ["c", "v", "l"].includes(e.key.toLowerCase()))
        ) {
          e.preventDefault();
        }
      }
    });
  }

  animate() {
    this.animationId = requestAnimationFrame(() => this.animate());
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  dispose() {
    if (this.animationId) cancelAnimationFrame(this.animationId);
    if (this.renderer) this.renderer.dispose();
    if (this.terminalTexture) this.terminalTexture.dispose();
  }
}
</file>

<file path="src/commands/filesystem.rs">
use lazy_static::lazy_static;
use std::collections::HashMap;
use std::sync::Mutex;

#[derive(Clone, Debug)]
pub enum Node {
    File {
        content: String,
        permissions: u16,
        owner: String,
        protected: bool,
    },
    Directory {
        children: HashMap<String, Node>,
        permissions: u16,
        owner: String,
        protected: bool,
    },
    Symlink {
        target: String,
        owner: String,
    },
}

impl Node {
    fn _is_directory(&self) -> bool {
        matches!(self, Node::Directory { .. })
    }

    fn _is_file(&self) -> bool {
        matches!(self, Node::File { .. })
    }

    fn is_protected(&self) -> bool {
        match self {
            Node::File { protected, .. } => *protected,
            Node::Directory { protected, .. } => *protected,
            Node::Symlink { .. } => false,
        }
    }

    fn get_owner(&self) -> &str {
        match self {
            Node::File { owner, .. } => owner,
            Node::Directory { owner, .. } => owner,
            Node::Symlink { owner, .. } => owner,
        }
    }
}

lazy_static! {
    pub static ref FILESYSTEM: Mutex<Node> = Mutex::new({
        use Node::*;
        Directory {
            permissions: 0o755,
            owner: "root".to_string(),
            protected: true,
            children: HashMap::from([
                (
                    "home".into(),
                    Directory {
                        permissions: 0o755,
                        owner: "root".to_string(),
                        protected: false,
                        children: HashMap::from([(
                            "objz".into(),
                            Directory {
                                permissions: 0o755,
                                owner: "objz".to_string(),
                                protected: false,
                                children: HashMap::from([
                                    (
                                        "projects".into(),
                                        Directory {
                                            permissions: 0o755,
                                            owner: "objz".to_string(),
                                            protected: true, // Protected!
                                            children: HashMap::from([(
                                                "readme.md".into(),
                                                File {
                                                    content: "# Projects\n\nThis is the projects folder.\nContains all my development work.".into(),
                                                    permissions: 0o644,
                                                    owner: "objz".to_string(),
                                                    protected: true,
                                                }
                                            )]),
                                        }
                                    ),
                                    (
                                        "about.txt".into(),
                                        File {
                                            content: "I'm objz ‚Äì a developer from Bavaria.\nI love Rust and WebAssembly!".into(),
                                            permissions: 0o644,
                                            owner: "objz".to_string(),
                                            protected: true, // Protected!
                                        }
                                    ),
                                    (
                                        "contact.txt".into(),
                                        File {
                                            content: "Email: me@objz.dev\nGitHub: @objz\nLocation: Bavaria, Germany".into(),
                                            permissions: 0o644,
                                            owner: "objz".to_string(),
                                            protected: true, // Protected!
                                        }
                                    ),
                                    (
                                        ".bashrc".into(),
                                        File {
                                            content: "# ~/.bashrc\nexport PS1='\\u@\\h:\\w\\$ '\nalias ll='ls -la'".into(),
                                            permissions: 0o644,
                                            owner: "objz".to_string(),
                                            protected: false,
                                        }
                                    ),
                                ]),
                            }
                        )]),
                    }
                ),
                (
                    "etc".into(),
                    Directory {
                        permissions: 0o755,
                        owner: "root".to_string(),
                        protected: true, // Protected!
                        children: HashMap::from([(
                            "hostname".into(),
                            File {
                                content: "wasm-host".into(),
                                permissions: 0o644,
                                owner: "root".to_string(),
                                protected: true,
                            }
                        )]),
                    }
                ),
                (
                    "tmp".into(),
                    Directory {
                        permissions: 0o1777,
                        owner: "root".to_string(),
                        protected: false,
                        children: HashMap::new(),
                    }
                ),
                (
                    "usr".into(),
                    Directory {
                        permissions: 0o755,
                        owner: "root".to_string(),
                        protected: true,
                        children: HashMap::from([(
                            "bin".into(),
                            Directory {
                                permissions: 0o755,
                                owner: "root".to_string(),
                                protected: true,
                                children: HashMap::new(),
                            }
                        )]),
                    }
                ),
            ])
        }
    });
    pub static ref CURRENT_PATH: Mutex<Vec<String>> = Mutex::new(vec!["home".to_string(), "objz".to_string()]);
    static ref CURRENT_USER: String = "anonym".to_string();
}

pub fn get_filesystem_entries(path: &[String], dirs_only: bool) -> Vec<String> {
    let filesystem = FILESYSTEM.lock().unwrap();

    match get_node_at_path(&filesystem, path) {
        Some(Node::Directory { children, .. }) => {
            let mut entries: Vec<String> = children
                .iter()
                .filter_map(|(name, node)| {
                    if dirs_only {
                        match node {
                            Node::Directory { .. } => Some(format!("{}/", name)),
                            _ => None,
                        }
                    } else {
                        match node {
                            Node::Directory { .. } => Some(format!("{}/", name)),
                            Node::File { .. } => Some(name.clone()),
                            Node::Symlink { .. } => Some(format!("{}@", name)),
                        }
                    }
                })
                .collect();

            entries.sort();
            entries
        }
        _ => Vec::new(),
    }
}

pub fn normalize_path(path: &str, current: &[String]) -> Vec<String> {
    if path.starts_with('/') {
        let mut result = Vec::new();
        for part in path.split('/').filter(|s| !s.is_empty()) {
            match part {
                "." => continue,
                ".." => {
                    result.pop();
                }
                _ => result.push(part.to_string()),
            }
        }
        result
    } else {
        let mut result = current.to_vec();
        for part in path.split('/').filter(|s| !s.is_empty()) {
            match part {
                "." => continue,
                ".." => {
                    result.pop();
                }
                _ => result.push(part.to_string()),
            }
        }
        result
    }
}

pub fn get_node_at_path<'a>(root: &'a Node, path: &[String]) -> Option<&'a Node> {
    let mut current = root;
    for part in path {
        if let Node::Directory { children, .. } = current {
            current = children.get(part)?;
        } else {
            return None;
        }
    }
    Some(current)
}

fn get_node_at_path_mut<'a>(root: &'a mut Node, path: &[String]) -> Option<&'a mut Node> {
    let mut current = root;
    for part in path {
        if let Node::Directory { children, .. } = current {
            current = children.get_mut(part)?;
        } else {
            return None;
        }
    }
    Some(current)
}

pub fn ls(args: &[&str]) -> String {
    let filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();

    let mut show_hidden = false;
    let mut long_format = false;
    let mut target_path = None;

    for arg in args {
        if arg.starts_with('-') {
            for c in arg.chars().skip(1) {
                match c {
                    'a' => show_hidden = true,
                    'l' => long_format = true,
                    _ => return format!("ls: invalid option -- '{}'", c),
                }
            }
        } else {
            target_path = Some(*arg);
        }
    }

    let path = if let Some(target) = target_path {
        normalize_path(target, &current_path)
    } else {
        current_path.clone()
    };

    let node = match get_node_at_path(&filesystem, &path) {
        Some(node) => node,
        None => return "ls: cannot access: No such file or directory".into(),
    };

    match node {
        Node::Directory { children, .. } => {
            let mut entries: Vec<_> = children.iter().collect();
            entries.sort_by_key(|(name, _)| name.as_str());

            if long_format {
                let mut output = String::new();
                for (name, node) in &entries {
                    if !show_hidden && name.starts_with('.') {
                        continue;
                    }

                    let (file_type, permissions, size) = match node {
                        Node::Directory { permissions, .. } => ('d', *permissions, 4096),
                        Node::File {
                            permissions,
                            content,
                            ..
                        } => ('-', *permissions, content.len()),
                        Node::Symlink { .. } => ('l', 0o777, 0),
                    };

                    output.push_str(&format!(
                        "{}{:o} 1 objz objz {:>8} {} {}\n",
                        file_type, permissions, size, "Jan  1 12:00", name
                    ));
                }
                output
            } else {
                entries
                    .iter()
                    .filter(|(name, _)| show_hidden || !name.starts_with('.'))
                    .map(|(name, node)| match node {
                        Node::Directory { .. } => format!("{}/", name),
                        Node::File { .. } => name.to_string(),
                        Node::Symlink { .. } => format!("{}@", name),
                    })
                    .collect::<Vec<_>>()
                    .join("  ")
            }
        }
        Node::File { .. } => target_path.unwrap_or(".").to_string(),
        Node::Symlink { target, .. } => format!("-> {}", target),
    }
}

pub fn cd(args: &[&str]) -> String {
    if args.is_empty() {
        {
            let mut path = CURRENT_PATH.lock().unwrap();
            *path = vec!["home".to_string(), "objz".to_string()];
        }
        return String::new();
    }

    let new_path = {
        let filesystem = FILESYSTEM.lock().unwrap();
        let current_path = CURRENT_PATH.lock().unwrap();

        let new_path = normalize_path(args[0], &current_path);

        match get_node_at_path(&filesystem, &new_path) {
            Some(Node::Directory { .. }) => new_path,
            Some(Node::Symlink { target, .. }) => {
                let symlink_path = normalize_path(target, &current_path);
                match get_node_at_path(&filesystem, &symlink_path) {
                    Some(Node::Directory { .. }) => symlink_path,
                    Some(_) => return format!("cd: {}: Not a directory", args[0]),
                    None => return format!("cd: {}: No such file or directory", args[0]),
                }
            }
            Some(_) => return format!("cd: {}: Not a directory", args[0]),
            None => return format!("cd: {}: No such file or directory", args[0]),
        }
    };

    {
        let mut path = CURRENT_PATH.lock().unwrap();
        *path = new_path;
    }
    String::new()
}

pub fn pwd(_: &[&str]) -> String {
    let path = CURRENT_PATH.lock().unwrap();
    if path.is_empty() {
        "/".into()
    } else {
        format!("/{}", path.join("/"))
    }
}

pub fn cat(args: &[&str]) -> String {
    if args.is_empty() {
        return "cat: missing file operand".into();
    }

    let filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();

    let mut output = String::new();

    for &filename in args {
        let file_path = normalize_path(filename, &current_path);

        match get_node_at_path(&filesystem, &file_path) {
            Some(Node::File { content, .. }) => {
                output.push_str(content);
                if args.len() > 1 && filename != args[args.len() - 1] {
                    output.push('\n');
                }
            }
            Some(Node::Directory { .. }) => {
                output.push_str(&format!("cat: {}: Is a directory\n", filename));
            }
            Some(Node::Symlink { target, .. }) => {
                output.push_str(&format!(
                    "cat: {}: Symbolic link (points to {})\n",
                    filename, target
                ));
            }
            None => {
                output.push_str(&format!("cat: {}: No such file or directory\n", filename));
            }
        }
    }

    output.trim_end().to_string()
}

pub fn mkdir(args: &[&str]) -> String {
    if args.is_empty() {
        return "mkdir: missing operand".into();
    }

    let mut filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();
    let current_user = &*CURRENT_USER;

    for &dirname in args {
        let dir_path = normalize_path(dirname, &current_path);

        if dir_path.is_empty() {
            return "mkdir: cannot create directory '/': File exists".into();
        }

        let parent_path = &dir_path[..dir_path.len() - 1];
        let dir_name = &dir_path[dir_path.len() - 1];

        let parent = match get_node_at_path_mut(&mut filesystem, parent_path) {
            Some(Node::Directory { children, .. }) => children,
            Some(_) => {
                return format!(
                    "mkdir: cannot create directory '{}': Not a directory",
                    dirname
                )
            }
            None => {
                return format!(
                    "mkdir: cannot create directory '{}': No such file or directory",
                    dirname
                )
            }
        };

        if parent.contains_key(dir_name) {
            return format!("mkdir: cannot create directory '{}': File exists", dirname);
        }

        parent.insert(
            dir_name.clone(),
            Node::Directory {
                permissions: 0o755,
                owner: current_user.clone(),
                protected: false,
                children: HashMap::new(),
            },
        );
    }

    String::new()
}

pub fn touch(args: &[&str]) -> String {
    if args.is_empty() {
        return "touch: missing file operand".into();
    }

    let mut filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();
    let current_user = &*CURRENT_USER;

    for &filename in args {
        let file_path = normalize_path(filename, &current_path);

        if file_path.is_empty() {
            continue;
        }

        let parent_path = &file_path[..file_path.len() - 1];
        let file_name = &file_path[file_path.len() - 1];

        let parent = match get_node_at_path_mut(&mut filesystem, parent_path) {
            Some(Node::Directory { children, .. }) => children,
            Some(_) => return format!("touch: cannot touch '{}': Not a directory", filename),
            None => {
                return format!(
                    "touch: cannot touch '{}': No such file or directory",
                    filename
                )
            }
        };

        if !parent.contains_key(file_name) {
            parent.insert(
                file_name.clone(),
                Node::File {
                    content: String::new(),
                    permissions: 0o644,
                    owner: current_user.clone(),
                    protected: false,
                },
            );
        }
    }

    String::new()
}

pub fn rm(args: &[&str]) -> String {
    if args.is_empty() {
        return "rm: missing operand".into();
    }

    let mut filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();
    let current_user = &*CURRENT_USER;

    let mut recursive = false;
    let mut force = false;
    let mut files = Vec::new();

    for &arg in args {
        if arg.starts_with('-') {
            for c in arg.chars().skip(1) {
                match c {
                    'r' | 'R' => recursive = true,
                    'f' => force = true,
                    _ => return format!("rm: invalid option -- '{}'", c),
                }
            }
        } else {
            files.push(arg);
        }
    }

    for filename in files {
        let file_path = normalize_path(filename, &current_path);

        if file_path.is_empty() {
            if !force {
                return "rm: cannot remove '/': Permission denied".into();
            }
            continue;
        }

        let parent_path = &file_path[..file_path.len() - 1];
        let file_name = &file_path[file_path.len() - 1];

        let parent = match get_node_at_path_mut(&mut filesystem, parent_path) {
            Some(Node::Directory { children, .. }) => children,
            Some(_) => {
                if !force {
                    return format!("rm: cannot remove '{}': Not a directory", filename);
                }
                continue;
            }
            None => {
                if !force {
                    return format!(
                        "rm: cannot remove '{}': No such file or directory",
                        filename
                    );
                }
                continue;
            }
        };

        match parent.get(file_name) {
            Some(node) => {
                if node.is_protected() {
                    return format!(
                        "rm: cannot remove '{}': Operation not permitted (protected system file)",
                        filename
                    );
                }

                if node.get_owner() != current_user && current_user != "root" {
                    return format!(
                        "rm: cannot remove '{}': Permission denied (not owner)",
                        filename
                    );
                }

                match node {
                    Node::Directory { .. } => {
                        if !recursive {
                            if !force {
                                return format!("rm: cannot remove '{}': Is a directory", filename);
                            }
                            continue;
                        }
                        parent.remove(file_name);
                    }
                    Node::File { .. } | Node::Symlink { .. } => {
                        parent.remove(file_name);
                    }
                }
            }
            None => {
                if !force {
                    return format!(
                        "rm: cannot remove '{}': No such file or directory",
                        filename
                    );
                }
            }
        }
    }

    String::new()
}

pub fn tree(args: &[&str]) -> String {
    let filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();

    let start_path = if args.is_empty() {
        current_path.clone()
    } else {
        normalize_path(args[0], &current_path)
    };

    let start_node = match get_node_at_path(&filesystem, &start_path) {
        Some(node) => node,
        None => return "tree: No such file or directory".into(),
    };

    fn build_tree(node: &Node, prefix: &str, _is_last: bool) -> String {
        let mut output = String::new();

        if let Node::Directory { children, .. } = node {
            let mut entries: Vec<_> = children.iter().collect();
            entries.sort_by_key(|(name, _)| name.as_str());

            for (i, (name, child)) in entries.iter().enumerate() {
                let is_last_child = i == entries.len() - 1;
                let connector = if is_last_child {
                    "‚îî‚îÄ‚îÄ "
                } else {
                    "‚îú‚îÄ‚îÄ "
                };

                let display_name = match child {
                    Node::Directory { .. } => format!("{}/", name),
                    Node::File { .. } => name.to_string(),
                    Node::Symlink { target, .. } => format!("{} -> {}", name, target),
                };

                output.push_str(&format!("{}{}{}\n", prefix, connector, display_name));

                let new_prefix =
                    format!("{}{}", prefix, if is_last_child { "    " } else { "‚îÇ   " });

                output.push_str(&build_tree(child, &new_prefix, is_last_child));
            }
        }

        output
    }

    let tree_name = if start_path.is_empty() {
        "/".to_string()
    } else {
        start_path.last().unwrap_or(&"/".to_string()).clone()
    };

    format!("{}\n{}", tree_name, build_tree(start_node, "", true))
}

pub fn ln(args: &[&str]) -> String {
    if args.len() < 2 {
        return "ln: missing file operand".into();
    }

    let mut filesystem = FILESYSTEM.lock().unwrap();
    let current_path = CURRENT_PATH.lock().unwrap();
    let current_user = &*CURRENT_USER;

    let (target, link_name) = if args[0] == "-s" {
        if args.len() < 3 {
            return "ln: missing file operand".into();
        }
        (args[1], args[2])
    } else {
        return "ln: hard links not supported in this filesystem".into();
    };

    let link_path = normalize_path(link_name, &current_path);

    if link_path.is_empty() {
        return "ln: cannot create link '/': File exists".into();
    }

    let parent_path = &link_path[..link_path.len() - 1];
    let file_name = &link_path[link_path.len() - 1];

    let parent = match get_node_at_path_mut(&mut filesystem, parent_path) {
        Some(Node::Directory { children, .. }) => children,
        Some(_) => return format!("ln: cannot create link '{}': Not a directory", link_name),
        None => {
            return format!(
                "ln: cannot create link '{}': No such file or directory",
                link_name
            )
        }
    };

    if parent.contains_key(file_name) {
        return format!("ln: cannot create link '{}': File exists", link_name);
    }

    parent.insert(
        file_name.clone(),
        Node::Symlink {
            target: target.to_string(),
            owner: current_user.clone(),
        },
    );

    String::new()
}

pub fn uname(args: &[&str]) -> String {
    if args.is_empty() || args[0] == "-s" {
        "WASM".to_string()
    } else if args[0] == "-a" {
        "WASM wasm-host 1.0.0 #1 SMP PREEMPT_DYNAMIC Mon Jan 1 12:00:00 UTC 2024 wasm32 GNU/Linux"
            .to_string()
    } else {
        "uname: invalid option".to_string()
    }
}
</file>

<file path="src/commands/misc.rs">
pub fn help(_args: &[&str]) -> String {
    r#"Available commands:

System Info:
  uname       - System information
  uptime      - System uptime
  neofetch    - Detailed system info
  date        - Current date and time

File System:
  ls, ll      - List directory contents
  cd          - Change directory
  pwd         - Print working directory
  cat         - Display file contents
  tree        - Display directory tree
  mkdir       - Create directory
  touch       - Create empty file
  rm          - Remove files/directories
  ln          - Create symbolic links

Utilities:
  clear       - Clear screen
  history     - Command history
  echo        - Display text
  cowsay      - ASCII cow with message
  sl          - Steam locomotive
  lolcat      - Rainbow text
  calc        - Calculator
  sudo        - Sudo access


Type `ls`, then `cd projects` and `ls` again.  
Run a project with `./project-name`.""#
        .to_string()
}

pub fn sudo(args: &[&str]) -> String {
    if args.len() >= 3 && args[0] == "rm" && args[1] == "-rf" && args[2] == "/" {
        "SYSTEM_PANIC".to_string()
    } else {
        "[sudo] password for objz: \n\nSorry, try again.\n[sudo] password for objz: \n\nSudo access denied for portfolio demo.".to_string()
    }
}

pub fn cowsay(args: &[&str]) -> String {
    let message = if args.is_empty() {
        "Hello from WASM!"
    } else {
        &args.join(" ")
    };

    let bubble_line = "-".repeat(message.len() + 2);

    format!(
        r#" {}
< {} >
 {}
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||"#,
        bubble_line, message, bubble_line
    )
}

pub fn sl(_args: &[&str]) -> String {
    r#"                 (@@) (  ) (@)  ( )  @@    ()    @     O     @     O      @
            (   )
        (@@@@)
     (    )

   (@@@)
====        ________                ___________
_D _|  |_______/        \__I_I_____===__|_________|
 |(_)---  |   H\________/ |   |        =|___ ___|      _________________
 /     |  |   H  |  |     |   |         ||_| |_||     _|                \_____A
|      |  |   H  |__--------------------| [___] |   =|                        |
| ________|___H__/__|_____/[][]~\_______|       |   -|                        |
|/ |   |-----------I_____I [][] []  D   |=======|____|________________________|_
__/ =| o |=-~O=====O=====O=====O\ ____Y___________|__|__________________________|_
 |/-=|___|=    ||    ||    ||    |_____/~\___/          |_D__D__D_|  |_D__D__D_|
  \_/      \__/  \__/  \__/  \__/      \_/               \_/   \_/    \_/   \_/

You have new mail."#
        .to_string()
}

pub fn lolcat(args: &[&str]) -> String {
    if args.is_empty() {
        "Usage: lolcat <text>".to_string()
    } else {
        format!("üåà {} üåà", args.join(" "))
    }
}

pub fn calc(args: &[&str]) -> String {
    if args.is_empty() {
        return "Usage: calc <expression>\nExample: calc 2 + 2".to_string();
    }

    let expression = args.join(" ");

    if let Some(result) = evaluate(&expression) {
        format!("{} = {}", expression, result)
    } else {
        format!("Error: Cannot evaluate '{}'", expression)
    }
}

fn evaluate(expr: &str) -> Option<f64> {
    let parts: Vec<&str> = expr.split_whitespace().collect();

    if parts.len() == 3 {
        if let (Ok(a), Ok(b)) = (parts[0].parse::<f64>(), parts[2].parse::<f64>()) {
            match parts[1] {
                "+" => Some(a + b),
                "-" => Some(a - b),
                "*" => Some(a * b),
                "/" if b != 0.0 => Some(a / b),
                _ => None,
            }
        } else {
            None
        }
    } else {
        None
    }
}
</file>

<file path="src/commands/processor.rs">
use crate::commands::{filesystem, system};

use super::misc;

#[derive(Clone)]
pub struct CommandHandler {
    history: Vec<String>,
}

impl CommandHandler {
    pub fn new() -> Self {
        Self {
            history: Vec::new(),
        }
    }

    pub fn get_current_directory(&self) -> String {
        filesystem::pwd(&[])
    }

    pub fn handle(&mut self, input: &str) -> (String, bool) {
        let trimmed = input.trim();
        if trimmed.is_empty() {
            return (String::new(), false);
        }

        self.history.push(trimmed.to_string());
        let parts: Vec<&str> = trimmed.split_whitespace().collect();
        let cmd = parts[0];
        let args = &parts[1..];

        let directory_changed = cmd == "cd";

        let output = match cmd {
            "clear" => system::clear(args),
            "history" => self.show_history(args),
            "echo" => system::echo(args),
            "date" => system::date(args),
            "uptime" => system::uptime(args),
            "neofetch" => system::neofetch(args),

            "ls" => filesystem::ls(args),
            "cd" => filesystem::cd(args),
            "cat" => filesystem::cat(args),
            "pwd" => filesystem::pwd(args),
            "tree" => filesystem::tree(args),
            "mkdir" => filesystem::mkdir(args),
            "touch" => filesystem::touch(args),
            "rm" => filesystem::rm(args),
            "uname" => filesystem::uname(args),
            "ln" => filesystem::ln(args),
            "ll" => filesystem::ls(&["-la"]),

            "help" => misc::help(args),
            "sudo" => misc::sudo(args),
            "cowsay" => misc::cowsay(args),
            "sl" => misc::sl(args),
            "lolcat" => misc::lolcat(args),
            "calc" => misc::calc(args),

            _ => format!("zsh: {}: command not found", cmd),
        };

        (output, directory_changed)
    }

    fn show_history(&self, _args: &[&str]) -> String {
        if self.history.is_empty() {
            "No commands in history yet.".to_string()
        } else {
            self.history
                .iter()
                .enumerate()
                .map(|(i, cmd)| format!("  {}  {}", i + 1, cmd))
                .collect::<Vec<_>>()
                .join("\n")
        }
    }
}
</file>

<file path="src/input/setup.rs">
use crate::input::history::CommandHistory;
use crate::terminal::Terminal;
use crate::utils::panic;
use crate::{input::autoscroll::ensure_autoscroll, terminal::renderer::LineOptions};
use js_sys::Promise;
use std::cell::RefCell;
use std::rc::Rc;
use wasm_bindgen::closure::Closure;
use wasm_bindgen::JsCast;
use wasm_bindgen_futures::{spawn_local, JsFuture};
use web_sys::{window, Event, HtmlTextAreaElement, KeyboardEvent};

impl Terminal {
    pub fn init_shell(&self) {
        self.create_prompt_input();
        self.show_prompt();
        self.setup_input_handlers();
    }

    fn create_prompt_input(&self) {
        let doc = window().unwrap().document().unwrap();

        let prompt_div = doc.create_element("div").unwrap();
        prompt_div.set_class_name("prompt-line");

        let label = doc.create_element("span").unwrap();
        label.set_class_name("prompt");
        label.set_text_content(Some(&self.get_current_prompt()));

        let textarea = doc
            .create_element("textarea")
            .unwrap()
            .dyn_into::<HtmlTextAreaElement>()
            .unwrap();
        textarea.set_id("terminal-input");
        textarea.set_class_name("terminal-input");
        textarea.set_attribute("autocomplete", "off").unwrap();
        textarea.set_attribute("spellcheck", "false").unwrap();
        textarea.set_attribute("rows", "1").unwrap();
        textarea.set_attribute("wrap", "soft").unwrap();

        prompt_div.append_child(&label).unwrap();
        prompt_div.append_child(&textarea).unwrap();
        self.canvas.append_child(&prompt_div).unwrap();

        ensure_autoscroll();
    }

    fn setup_input_handlers(&self) {
        self.setup_auto_resize();
        self.setup_typing_animation();
        self.setup_key_handler();
    }

    fn setup_auto_resize(&self) {
        let doc = window().unwrap().document().unwrap();
        let input = doc.get_element_by_id("terminal-input").unwrap();
        let clone = input.clone();

        let on_input = Closure::wrap(Box::new(move |_e: Event| {
            if let Some(tx) = clone.dyn_ref::<HtmlTextAreaElement>() {
                tx.style().set_property("height", "auto").unwrap();
                let scroll_h = tx.scroll_height();

                let line_h = 22;
                let max_lines = 10;

                let min_h = line_h;
                let max_h = line_h * max_lines;
                let h = scroll_h.max(min_h).min(max_h);

                tx.style()
                    .set_property("height", &format!("{}px", h))
                    .unwrap();

                let rows = (h / line_h).max(1);
                tx.set_attribute("rows", &rows.to_string()).unwrap();
            }
        }) as Box<dyn FnMut(_)>);

        input
            .add_event_listener_with_callback("input", on_input.as_ref().unchecked_ref())
            .unwrap();
        on_input.forget();
    }

    fn setup_typing_animation(&self) {
        let doc = window().unwrap().document().unwrap();
        let input = doc.get_element_by_id("terminal-input").unwrap();
        let clone = input.clone();

        let on_input = Closure::wrap(Box::new(move |_e: Event| {
            if let Some(tx) = clone.dyn_ref::<HtmlTextAreaElement>() {
                tx.set_class_name("terminal-input typing");
                let tx_clone = tx.clone();

                let rm_typing = Closure::wrap(Box::new(move || {
                    tx_clone.set_class_name("terminal-input");
                }) as Box<dyn FnMut()>);

                window()
                    .unwrap()
                    .set_timeout_with_callback_and_timeout_and_arguments_0(
                        rm_typing.as_ref().unchecked_ref(),
                        150,
                    )
                    .unwrap();
                rm_typing.forget();
            }
        }) as Box<dyn FnMut(_)>);

        input
            .add_event_listener_with_callback("input", on_input.as_ref().unchecked_ref())
            .unwrap();
        on_input.forget();
    }

    fn setup_key_handler(&self) {
        let doc = window().unwrap().document().unwrap();
        let input = doc
            .get_element_by_id("terminal-input")
            .unwrap()
            .dyn_into::<HtmlTextAreaElement>()
            .unwrap();

        let mut history = {
            let mut h = CommandHistory::new(50);
            for cmd in &["help", "clear", "ls"] {
                h.add(cmd.to_string());
            }
            h
        };

        let mut processor = self.command_handler.clone();
        let base_prompt = self.base_prompt.clone();
        let clone_in = input.clone();
        let term_clone = self.clone();

        let autocomplete = Rc::new(RefCell::new(
            crate::terminal::autocomplete::AutoComplete::new(),
        ));

        let handler = Closure::wrap(Box::new(move |ev: KeyboardEvent| match ev.key().as_str() {
            "Tab" => {
                ev.prevent_default();
                Self::handle_tab_completion(
                    &clone_in,
                    &autocomplete,
                    &processor,
                    &base_prompt,
                    &term_clone,
                );
            }

            "Enter" if !ev.shift_key() => {
                ev.prevent_default();
                Self::handle_enter(
                    &clone_in,
                    &mut history,
                    &mut processor,
                    &base_prompt,
                    &term_clone,
                );
            }

            "ArrowUp" => {
                ev.prevent_default();
                Self::handle_history_up(&clone_in, &mut history);
            }

            "ArrowDown" => {
                ev.prevent_default();
                Self::handle_history_down(&clone_in, &mut history);
            }

            _ => {}
        }) as Box<dyn FnMut(_)>);

        input
            .add_event_listener_with_callback("keydown", handler.as_ref().unchecked_ref())
            .unwrap();
        handler.forget();
    }

    fn handle_tab_completion(
        input: &HtmlTextAreaElement,
        autocomplete: &Rc<RefCell<crate::terminal::autocomplete::AutoComplete>>,
        processor: &crate::commands::CommandHandler,
        base_prompt: &str,
        terminal: &Terminal,
    ) {
        let current_input = input.value();
        let current_path = {
            use crate::commands::filesystem::CURRENT_PATH;
            CURRENT_PATH.lock().unwrap().clone()
        };

        let completion_result = autocomplete
            .borrow_mut()
            .complete(&current_input, &current_path);

        match completion_result {
            crate::terminal::autocomplete::CompletionResult::Single(completion) => {
                let parts: Vec<&str> = current_input.trim().split_whitespace().collect();
                if parts.len() <= 1 {
                    input.set_value(&format!("{} ", completion));
                } else {
                    let mut new_parts = parts[..parts.len() - 1].to_vec();
                    new_parts.push(&completion);
                    input.set_value(&format!("{} ", new_parts.join(" ")));
                }
                let text_length = input.value().len() as u32;
                let _ = input.set_selection_range(text_length, text_length);
            }

            crate::terminal::autocomplete::CompletionResult::Multiple(matches) => {
                let current_prompt = Self::build_prompt(processor, base_prompt);
                let line = format!("{}{}", current_prompt, current_input);

                let term_clone_for_line = terminal.clone();
                spawn_local(async move {
                    term_clone_for_line
                        .add_line(&line, Some(LineOptions::new().with_color("command")))
                        .await;
                });

                Self::display_completions(&matches, terminal);

                if let Some(common) = crate::terminal::autocomplete::find_common_prefix(&matches) {
                    let parts: Vec<&str> = current_input.trim().split_whitespace().collect();
                    if parts.len() <= 1 && common.len() > current_input.trim().len() {
                        input.set_value(&common);
                    } else if parts.len() > 1 {
                        let prefix = parts[..parts.len() - 1].join(" ");
                        input.set_value(&format!("{} {}", prefix, common));
                    }
                }
                ensure_autoscroll();
            }

            crate::terminal::autocomplete::CompletionResult::None => {}
        }
    }

    fn handle_enter(
        input: &HtmlTextAreaElement,
        history: &mut CommandHistory,
        processor: &mut crate::commands::CommandHandler,
        base_prompt: &str,
        terminal: &Terminal,
    ) {
        let val = input.value();
        if !val.trim().is_empty() {
            history.add(val.clone());
        }

        input.set_value("");
        input.style().set_property("height", "auto").unwrap();
        input.set_attribute("rows", "1").unwrap();

        let current_prompt = Self::build_prompt(processor, base_prompt);
        let line = format!("{}{}", current_prompt, val);

        let term_clone_for_command = terminal.clone();
        spawn_local(async move {
            term_clone_for_command
                .add_line(&line, Some(LineOptions::new().with_color("command")))
                .await;
        });
        ensure_autoscroll();

        let (result, directory_changed) = processor.handle(&val);

        match result.as_str() {
            "CLEAR_SCREEN" => terminal.clear_output(),
            "SYSTEM_PANIC" => {
                let panic_clone = terminal.clone();
                spawn_local(async move {
                    panic::system_panic(&panic_clone).await;
                });
            }
            _ => {
                Self::display_command_output(&result, terminal);
            }
        }

        if directory_changed {
            Self::update_prompt_display(processor, base_prompt);
        }
    }

    fn handle_history_up(input: &HtmlTextAreaElement, history: &mut CommandHistory) {
        if let Some(cmd) = history.previous() {
            input.set_value(&cmd);
            input.focus().unwrap();
            let len = cmd.len() as u32;
            let _ = input.set_selection_range(len, len);

            let input_clone = input.clone();
            let timeout = Closure::wrap(Box::new(move || {
                let _ = input_clone.set_selection_range(len, len);
            }) as Box<dyn FnMut()>);

            window()
                .unwrap()
                .set_timeout_with_callback_and_timeout_and_arguments_0(
                    timeout.as_ref().unchecked_ref(),
                    0,
                )
                .unwrap();
            timeout.forget();
        }
    }

    fn handle_history_down(input: &HtmlTextAreaElement, history: &mut CommandHistory) {
        if let Some(cmd) = history.next() {
            input.set_value(&cmd);
        } else {
            input.set_value("");
        }
    }

    fn build_prompt(processor: &crate::commands::CommandHandler, base_prompt: &str) -> String {
        let cwd = processor.get_current_directory();
        let display_path = if cwd == "/home/objz" {
            "~".to_string()
        } else if cwd.starts_with("/home/objz/") {
            format!("~{}", &cwd["/home/objz".len()..])
        } else {
            cwd
        };
        format!("{}:{}$ ", base_prompt, display_path)
    }

    fn display_completions(matches: &[String], terminal: &Terminal) {
        let matches_per_line = 4;
        let mut output = String::new();

        for chunk in matches.chunks(matches_per_line) {
            let row = chunk
                .iter()
                .map(|s| format!("{:<20}", s))
                .collect::<Vec<_>>()
                .join("");
            output.push_str(&row);
            output.push('\n');
        }

        let term_clone_for_output = terminal.clone();
        spawn_local(async move {
            for line in output.lines() {
                if !line.trim().is_empty() {
                    term_clone_for_output
                        .add_line(&line, Some(LineOptions::new().with_color("completion")))
                        .await;
                }
            }
        });
    }

    fn display_command_output(result: &str, terminal: &Terminal) {
        let term_clone_for_output = terminal.clone();
        let lines: Vec<String> = result.lines().map(str::to_owned).collect();

        spawn_local(async move {
            for line in lines {
                term_clone_for_output.add_line(&line, None).await;

                let promise = Promise::new(&mut |resolve, _| {
                    window()
                        .unwrap()
                        .set_timeout_with_callback_and_timeout_and_arguments_0(&resolve, 0)
                        .unwrap();
                });
                let _ = JsFuture::from(promise).await;
            }
        });
    }

    fn update_prompt_display(processor: &crate::commands::CommandHandler, base_prompt: &str) {
        let doc = window().unwrap().document().unwrap();
        if let Some(prompt_el) = doc.query_selector(".prompt-line .prompt").unwrap() {
            let new_prompt = Self::build_prompt(processor, base_prompt);
            prompt_el.set_text_content(Some(&new_prompt));
        }
    }

    fn show_prompt(&self) {
        let doc = window().unwrap().document().unwrap();
        let input = doc
            .get_element_by_id("terminal-input")
            .unwrap()
            .dyn_into::<HtmlTextAreaElement>()
            .unwrap();
        input.focus().unwrap();
        ensure_autoscroll();
    }
}
</file>

<file path="src/terminal/renderer.rs">
use crate::input::autoscroll::{ensure_autoscroll, trim_output};
use crate::terminal::Terminal;
use wasm_bindgen::JsValue;

#[derive(Default)]
pub struct LineOptions {
    pub color: Option<String>,
    pub typing_speed: Option<u32>,
    pub boot_animation: bool,
}

impl LineOptions {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_color(mut self, color: &str) -> Self {
        self.color = Some(color.to_string());
        self
    }

    pub fn with_typing(mut self, speed: u32) -> Self {
        self.typing_speed = Some(speed);
        self
    }

    pub fn with_boot_animation(mut self) -> Self {
        self.boot_animation = true;
        self
    }
}

impl Terminal {
    pub async fn add_line(&self, text: &str, options: Option<LineOptions>) {
        let opts = options.unwrap_or_default();

        if opts.boot_animation {
            self.boot(text, &opts).await;
        } else if let Some(speed) = opts.typing_speed {
            self.typing(text, speed, &opts).await;
        } else {
            self.simple(text, &opts).await;
        }
    }

    async fn boot(&self, task: &str, opts: &LineOptions) {
        let current_y = self.y.get();

        let spinner = ["‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è"];
        for &spin_char in &spinner[0..4] {
            let text = format!("{} {}", task, spin_char);
            self.clear_line_at_y(current_y);
            self.draw_text(&text, current_y, opts.color.as_deref());
            ensure_autoscroll();
            self.sleep(60).await;
        }

        let final_text = format!("{} [OK]", task);
        self.clear_line_at_y(current_y);
        self.draw_boot_line(&final_text, current_y, opts.color.as_deref());

        self.advance_y();
        trim_output(self.height);
        ensure_autoscroll();
    }

    async fn typing(&self, text: &str, speed: u32, opts: &LineOptions) {
        let current_y = self.y.get();

        let mut buf = String::new();
        let chars: Vec<char> = text.chars().collect();

        for (i, &ch) in chars.iter().enumerate() {
            buf.push(ch);
            self.clear_line_at_y(current_y);

            let display = if i < chars.len() - 1 {
                format!("{}‚ñà", buf)
            } else {
                buf.clone()
            };

            self.draw_typing_text(
                &display,
                current_y,
                opts.color.as_deref(),
                i < chars.len() - 1,
            );
            ensure_autoscroll();
            self.sleep(speed as i32).await;
        }

        self.clear_line_at_y(current_y);
        self.draw_text(&buf, current_y, opts.color.as_deref());

        self.advance_y();
        trim_output(self.height);
        ensure_autoscroll();
    }

    async fn simple(&self, text: &str, opts: &LineOptions) {
        self.append_line(text, opts.color.as_deref());
        ensure_autoscroll();
    }

    fn draw_text(&self, text: &str, y: f64, color: Option<&str>) {
        self.context.save();

        self.context.set_font("14px monospace");
        self.context.set_text_baseline("top");

        if let Some(color) = color {
            self.context
                .set_fill_style(&JsValue::from_str(&self.get_color_value(color)));
        } else {
            self.context.set_fill_style(&JsValue::from_str("#ffffff"));
        }

        self.context.fill_text(text, 10.0, y).unwrap();
        self.context.restore();
    }

    fn draw_boot_line(&self, text: &str, y: f64, color: Option<&str>) {
        self.context.save();

        self.context.set_font("14px monospace");
        self.context.set_text_baseline("top");

        if let Some(color) = color {
            self.context
                .set_fill_style(&JsValue::from_str(&self.get_color_value(color)));
        } else {
            self.context.set_fill_style(&JsValue::from_str("#ffffff"));
        }

        if let Some(ok_pos) = text.rfind(" [OK]") {
            let main_text = &text[..ok_pos];
            let ok_text = " [OK]";

            self.context.fill_text(main_text, 10.0, y).unwrap();

            let char_width = 8.4;
            let main_width = main_text.len() as f64 * char_width;

            self.context.set_fill_style(&JsValue::from_str("#00ff00"));
            self.context
                .fill_text(ok_text, 10.0 + main_width, y)
                .unwrap();
        } else {
            self.context.fill_text(text, 10.0, y).unwrap();
        }

        self.context.restore();
    }

    fn draw_typing_text(&self, text: &str, y: f64, color: Option<&str>, has_cursor: bool) {
        self.context.save();

        self.context.set_font("14px monospace");
        self.context.set_text_baseline("top");

        if let Some(color) = color {
            self.context
                .set_fill_style(&JsValue::from_str(&self.get_color_value(color)));
        } else {
            self.context.set_fill_style(&JsValue::from_str("#ffffff"));
        }

        if has_cursor {
            let text_without_cursor = &text[..text.len() - 1];
            let cursor = "‚ñà";

            self.context
                .fill_text(text_without_cursor, 10.0, y)
                .unwrap();

            let char_width = 8.4;
            let text_width = text_without_cursor.len() as f64 * char_width;

            self.context.set_fill_style(&JsValue::from_str("#00ff00"));
            self.context
                .fill_text(cursor, 10.0 + text_width, y)
                .unwrap();
        } else {
            self.context.fill_text(text, 10.0, y).unwrap();
        }

        self.context.restore();
    }

    fn clear_line_at_y(&self, y: f64) {
        self.context.save();
        self.context.set_fill_style(&JsValue::from_str("#000000"));
        // Fixed: Use self.width instead of canvas.width()
        self.context
            .fill_rect(0.0, y, self.width as f64, self.line_height);
        self.context.restore();
    }

    fn get_color_value(&self, color: &str) -> String {
        match color {
            "red" => "#ff0000".to_string(),
            "green" => "#00ff00".to_string(),
            "blue" => "#0000ff".to_string(),
            "yellow" => "#ffff00".to_string(),
            "cyan" => "#00ffff".to_string(),
            "magenta" => "#ff00ff".to_string(),
            "white" => "#ffffff".to_string(),
            "gray" | "grey" => "#808080".to_string(),
            "boot-line" => "#ffffff".to_string(),
            "typing-line" => "#ffffff".to_string(),
            _ => {
                if color.starts_with('#') || color.starts_with("rgb") {
                    color.to_string()
                } else {
                    "#ffffff".to_string()
                }
            }
        }
    }

    fn advance_y(&self) {
        let new_y = self.y.get() + self.line_height;
        self.y.set(new_y);
    }

    fn append_line(&self, text: &str, color: Option<&str>) {
        let current_y = self.y.get();
        self.draw_text(text, current_y, color);
        self.advance_y();
        trim_output(self.height);
    }

    pub fn clear_output(&self) {
        self.context.save();
        self.context.set_fill_style(&JsValue::from_str("#000000"));
        // Fixed: Use self.width and self.height instead of canvas methods
        self.context
            .fill_rect(0.0, 0.0, self.width as f64, self.height as f64);
        self.context.restore();

        self.y.set(20.0);
    }

    // Add a test method to verify rendering
    pub fn test_render(&self) {
        self.context.save();

        // Clear canvas
        self.context.set_fill_style(&JsValue::from_str("#000000"));
        self.context
            .fill_rect(0.0, 0.0, self.width as f64, self.height as f64);

        // Draw test information
        self.context.set_font("14px monospace");
        self.context.set_fill_style(&JsValue::from_str("#00ff00"));
        self.context
            .fill_text("Terminal Rendering Test", 10.0, 20.0)
            .unwrap();

        let dimensions = format!("Canvas: {}x{}", self.width, self.height);
        self.context.set_fill_style(&JsValue::from_str("#ffff00"));
        self.context.fill_text(&dimensions, 10.0, 50.0).unwrap();

        let prompt = self.get_current_prompt();
        self.context.set_fill_style(&JsValue::from_str("#8be9fd"));
        self.context.fill_text(&prompt, 10.0, 80.0).unwrap();

        // Draw border
        self.context.set_stroke_style(&JsValue::from_str("#ff0000"));
        self.context.set_line_width(2.0);
        self.context
            .stroke_rect(1.0, 1.0, (self.width - 2) as f64, (self.height - 2) as f64);

        self.context.restore();
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "portfolio"
version = "0.1.0"
authors = ["objz <me@objz.dev>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]

[dependencies]
wasm-bindgen = "0.2.84"
wasm-bindgen-futures = "0.4.37"
js-sys = "0.3.61"
console_error_panic_hook = { version = "0.1.7", optional = true }
lazy_static = "1.5.0"

[dependencies.web-sys]
version = "0.3.61"
features = [
  "console",
  "Document",
  "Element",
  "HtmlElement",
  "HtmlInputElement",
  "HtmlTextAreaElement",
  "KeyboardEvent",
  "Window",
  "EventTarget",
  "Event",
  "CssStyleDeclaration",
  "HtmlCanvasElement",
  "CanvasRenderingContext2d",
  "TextMetrics"
]

[profile.release]
opt-level = "s"
</file>

<file path="static/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>objz@portfolio:~$ _</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../style/styles.css" />
  </head>
  <body>
    <!-- Loading Screen -->
    <div id="loading">
      <div class="loading-text">Initializing...</div>
      <div class="loading-bar">
        <div class="loading-progress" id="loading-progress"></div>
      </div>
    </div>

    <div id="scene-container"></div>

    <canvas tabindex="0" id="terminal"></canvas>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module" src="../js/index.js"></script>
  </body>
</html>
</file>

<file path="src/lib.rs">
use commands::system;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::spawn_local;
use web_sys::window;

mod ascii_art;
mod boot;
mod commands;
mod input;
mod terminal;
mod utils;

use terminal::Terminal;

#[wasm_bindgen(start)]
pub fn main() {
    #[cfg(feature = "console_error_panic_hook")]
    console_error_panic_hook::set_once();

    system::init();

    let window = window().unwrap();
    let document = window.document().unwrap();

    let term = Terminal::new(&document);
    spawn_local(async move {
        term.init_boot().await;
        term.init_shell();
    });
}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

#[wasm_bindgen]
pub fn greet() {
    log("Terminal loaded");
}
</file>

<file path="style/styles.css">
/* Reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
  color: #e6e6e6;
  font-family:
    "JetBrains Mono", "Fira Code", "Source Code Pro", "Consolas", monospace;
  overflow: hidden;
}

/* 3D Scene Styles */
#scene-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 10;
}

/* Loading Screen */
#loading {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  color: #8be9fd;
  font-family: "JetBrains Mono", monospace;
  transition: opacity 0.5s ease;
}

#loading.hidden {
  opacity: 0;
  pointer-events: none;
}

.loading-text {
  font-size: 18px;
  text-shadow: 0 0 10px rgba(139, 233, 253, 0.5);
}

.loading-bar {
  background: #333;
  border-radius: 2px;
  overflow: hidden;
  width: 300px;
  height: 4px;
  margin-top: 20px;
}

.loading-progress {
  background: linear-gradient(90deg, #8be9fd, #50fa7b);
  transition: width 0.3s ease;
  box-shadow: 0 0 10px rgba(139, 233, 253, 0.3);
  height: 100%;
  width: 0%;
}

/* Terminal Canvas Styles */
#terminal {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 800px;
  height: 600px;
  z-index: 20;
  visibility: visible;
  background: #000000;

  /* Debug red outline */
  border: 3px solid #ff0000;
  box-shadow:
    0 0 10px rgba(255, 0, 0, 0.5),
    0 0 20px rgba(139, 233, 253, 0.3);

  /* Canvas specific styles */
  display: block;
  border-radius: 4px;

  /* Make it focusable */
  outline: none;

  /* Ensure crisp pixel rendering */
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

/* When terminal is focused */
#terminal:focus {
  border-color: #ff0000;
  box-shadow:
    0 0 15px rgba(255, 0, 0, 0.8),
    0 0 30px rgba(139, 233, 253, 0.5);
}

/* Terminal in texture mode (when being used as 3D texture) */
#terminal.texture-mode {
  visibility: hidden;
  position: fixed;
  top: -9999px;
  left: -9999px;
  z-index: -1;
}

/* Debug info overlay */
.debug-info {
  position: fixed;
  top: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: #00ff00;
  padding: 10px;
  font-family: monospace;
  font-size: 12px;
  border: 1px solid #00ff00;
  z-index: 1000;
  border-radius: 4px;
}

/* Media queries for responsive design */
@media (max-width: 1024px) {
  #terminal {
    width: 90vw;
    height: 70vh;
    max-width: 800px;
    max-height: 600px;
  }
}

@media (max-width: 768px) {
  #terminal {
    width: 95vw;
    height: 75vh;
    font-size: 14px;
  }
}
</file>

<file path="README.md">
Hi ![](https://user-images.githubusercontent.com/18350557/176309783-0785949b-9127-417c-8b55-ab5a4333674e.gif) My name is Consti
==============================================================================================================================

* I'm based in Bavaria - Germany
* I'm currently working on [CommandBridge](https://github.com/72-S/CommandBridge) and [mcl](https://github.com/72-S/mcl)

### Skills
[![My Skills](https://skillicons.dev/icons?i=c,cpp,rust,java,linux,arch,neovim)](https://skillicons.dev)


<img src="https://raw.githubusercontent.com/72-S/72-S/output/snake.svg" alt="Snake animation" />
</file>

</files>
